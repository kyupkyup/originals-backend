// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  book: (where?: BookWhereInput) => Promise<boolean>;
  bulletinList: (where?: BulletinListWhereInput) => Promise<boolean>;
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  like: (where?: LikeWhereInput) => Promise<boolean>;
  likeOnComment: (where?: LikeOnCommentWhereInput) => Promise<boolean>;
  meeting: (where?: MeetingWhereInput) => Promise<boolean>;
  participant: (where?: ParticipantWhereInput) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  reservation: (where?: ReservationWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  view: (where?: ViewWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  book: (where: BookWhereUniqueInput) => BookNullablePromise;
  books: (args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Book>;
  booksConnection: (args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BookConnectionPromise;
  bulletinList: (
    where: BulletinListWhereUniqueInput
  ) => BulletinListNullablePromise;
  bulletinLists: (args?: {
    where?: BulletinListWhereInput;
    orderBy?: BulletinListOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BulletinList>;
  bulletinListsConnection: (args?: {
    where?: BulletinListWhereInput;
    orderBy?: BulletinListOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BulletinListConnectionPromise;
  comment: (where: CommentWhereUniqueInput) => CommentNullablePromise;
  comments: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Comment>;
  commentsConnection: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentConnectionPromise;
  file: (where: FileWhereUniqueInput) => FileNullablePromise;
  files: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<File>;
  filesConnection: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FileConnectionPromise;
  like: (where: LikeWhereUniqueInput) => LikeNullablePromise;
  likes: (args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Like>;
  likesConnection: (args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LikeConnectionPromise;
  likeOnComment: (
    where: LikeOnCommentWhereUniqueInput
  ) => LikeOnCommentNullablePromise;
  likeOnComments: (args?: {
    where?: LikeOnCommentWhereInput;
    orderBy?: LikeOnCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LikeOnComment>;
  likeOnCommentsConnection: (args?: {
    where?: LikeOnCommentWhereInput;
    orderBy?: LikeOnCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LikeOnCommentConnectionPromise;
  meeting: (where: MeetingWhereUniqueInput) => MeetingNullablePromise;
  meetings: (args?: {
    where?: MeetingWhereInput;
    orderBy?: MeetingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Meeting>;
  meetingsConnection: (args?: {
    where?: MeetingWhereInput;
    orderBy?: MeetingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MeetingConnectionPromise;
  participant: (
    where: ParticipantWhereUniqueInput
  ) => ParticipantNullablePromise;
  participants: (args?: {
    where?: ParticipantWhereInput;
    orderBy?: ParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Participant>;
  participantsConnection: (args?: {
    where?: ParticipantWhereInput;
    orderBy?: ParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ParticipantConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostNullablePromise;
  posts: (args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Post>;
  postsConnection: (args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PostConnectionPromise;
  reservation: (
    where: ReservationWhereUniqueInput
  ) => ReservationNullablePromise;
  reservations: (args?: {
    where?: ReservationWhereInput;
    orderBy?: ReservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Reservation>;
  reservationsConnection: (args?: {
    where?: ReservationWhereInput;
    orderBy?: ReservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReservationConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  view: (where: ViewWhereUniqueInput) => ViewNullablePromise;
  views: (args?: {
    where?: ViewWhereInput;
    orderBy?: ViewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<View>;
  viewsConnection: (args?: {
    where?: ViewWhereInput;
    orderBy?: ViewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ViewConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBook: (data: BookCreateInput) => BookPromise;
  updateBook: (args: {
    data: BookUpdateInput;
    where: BookWhereUniqueInput;
  }) => BookPromise;
  updateManyBooks: (args: {
    data: BookUpdateManyMutationInput;
    where?: BookWhereInput;
  }) => BatchPayloadPromise;
  upsertBook: (args: {
    where: BookWhereUniqueInput;
    create: BookCreateInput;
    update: BookUpdateInput;
  }) => BookPromise;
  deleteBook: (where: BookWhereUniqueInput) => BookPromise;
  deleteManyBooks: (where?: BookWhereInput) => BatchPayloadPromise;
  createBulletinList: (data: BulletinListCreateInput) => BulletinListPromise;
  updateBulletinList: (args: {
    data: BulletinListUpdateInput;
    where: BulletinListWhereUniqueInput;
  }) => BulletinListPromise;
  updateManyBulletinLists: (args: {
    data: BulletinListUpdateManyMutationInput;
    where?: BulletinListWhereInput;
  }) => BatchPayloadPromise;
  upsertBulletinList: (args: {
    where: BulletinListWhereUniqueInput;
    create: BulletinListCreateInput;
    update: BulletinListUpdateInput;
  }) => BulletinListPromise;
  deleteBulletinList: (
    where: BulletinListWhereUniqueInput
  ) => BulletinListPromise;
  deleteManyBulletinLists: (
    where?: BulletinListWhereInput
  ) => BatchPayloadPromise;
  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (args: {
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
  }) => CommentPromise;
  updateManyComments: (args: {
    data: CommentUpdateManyMutationInput;
    where?: CommentWhereInput;
  }) => BatchPayloadPromise;
  upsertComment: (args: {
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
  }) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (args: {
    data: FileUpdateInput;
    where: FileWhereUniqueInput;
  }) => FilePromise;
  updateManyFiles: (args: {
    data: FileUpdateManyMutationInput;
    where?: FileWhereInput;
  }) => BatchPayloadPromise;
  upsertFile: (args: {
    where: FileWhereUniqueInput;
    create: FileCreateInput;
    update: FileUpdateInput;
  }) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createLike: (data: LikeCreateInput) => LikePromise;
  updateLike: (args: {
    data: LikeUpdateInput;
    where: LikeWhereUniqueInput;
  }) => LikePromise;
  upsertLike: (args: {
    where: LikeWhereUniqueInput;
    create: LikeCreateInput;
    update: LikeUpdateInput;
  }) => LikePromise;
  deleteLike: (where: LikeWhereUniqueInput) => LikePromise;
  deleteManyLikes: (where?: LikeWhereInput) => BatchPayloadPromise;
  createLikeOnComment: (data: LikeOnCommentCreateInput) => LikeOnCommentPromise;
  updateLikeOnComment: (args: {
    data: LikeOnCommentUpdateInput;
    where: LikeOnCommentWhereUniqueInput;
  }) => LikeOnCommentPromise;
  upsertLikeOnComment: (args: {
    where: LikeOnCommentWhereUniqueInput;
    create: LikeOnCommentCreateInput;
    update: LikeOnCommentUpdateInput;
  }) => LikeOnCommentPromise;
  deleteLikeOnComment: (
    where: LikeOnCommentWhereUniqueInput
  ) => LikeOnCommentPromise;
  deleteManyLikeOnComments: (
    where?: LikeOnCommentWhereInput
  ) => BatchPayloadPromise;
  createMeeting: (data: MeetingCreateInput) => MeetingPromise;
  updateMeeting: (args: {
    data: MeetingUpdateInput;
    where: MeetingWhereUniqueInput;
  }) => MeetingPromise;
  updateManyMeetings: (args: {
    data: MeetingUpdateManyMutationInput;
    where?: MeetingWhereInput;
  }) => BatchPayloadPromise;
  upsertMeeting: (args: {
    where: MeetingWhereUniqueInput;
    create: MeetingCreateInput;
    update: MeetingUpdateInput;
  }) => MeetingPromise;
  deleteMeeting: (where: MeetingWhereUniqueInput) => MeetingPromise;
  deleteManyMeetings: (where?: MeetingWhereInput) => BatchPayloadPromise;
  createParticipant: (data: ParticipantCreateInput) => ParticipantPromise;
  updateParticipant: (args: {
    data: ParticipantUpdateInput;
    where: ParticipantWhereUniqueInput;
  }) => ParticipantPromise;
  upsertParticipant: (args: {
    where: ParticipantWhereUniqueInput;
    create: ParticipantCreateInput;
    update: ParticipantUpdateInput;
  }) => ParticipantPromise;
  deleteParticipant: (where: ParticipantWhereUniqueInput) => ParticipantPromise;
  deleteManyParticipants: (
    where?: ParticipantWhereInput
  ) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (args: {
    data: PostUpdateInput;
    where: PostWhereUniqueInput;
  }) => PostPromise;
  updateManyPosts: (args: {
    data: PostUpdateManyMutationInput;
    where?: PostWhereInput;
  }) => BatchPayloadPromise;
  upsertPost: (args: {
    where: PostWhereUniqueInput;
    create: PostCreateInput;
    update: PostUpdateInput;
  }) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createReservation: (data: ReservationCreateInput) => ReservationPromise;
  updateReservation: (args: {
    data: ReservationUpdateInput;
    where: ReservationWhereUniqueInput;
  }) => ReservationPromise;
  updateManyReservations: (args: {
    data: ReservationUpdateManyMutationInput;
    where?: ReservationWhereInput;
  }) => BatchPayloadPromise;
  upsertReservation: (args: {
    where: ReservationWhereUniqueInput;
    create: ReservationCreateInput;
    update: ReservationUpdateInput;
  }) => ReservationPromise;
  deleteReservation: (where: ReservationWhereUniqueInput) => ReservationPromise;
  deleteManyReservations: (
    where?: ReservationWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createView: (data: ViewCreateInput) => ViewPromise;
  updateView: (args: {
    data: ViewUpdateInput;
    where: ViewWhereUniqueInput;
  }) => ViewPromise;
  upsertView: (args: {
    where: ViewWhereUniqueInput;
    create: ViewCreateInput;
    update: ViewUpdateInput;
  }) => ViewPromise;
  deleteView: (where: ViewWhereUniqueInput) => ViewPromise;
  deleteManyViews: (where?: ViewWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  book: (
    where?: BookSubscriptionWhereInput
  ) => BookSubscriptionPayloadSubscription;
  bulletinList: (
    where?: BulletinListSubscriptionWhereInput
  ) => BulletinListSubscriptionPayloadSubscription;
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  like: (
    where?: LikeSubscriptionWhereInput
  ) => LikeSubscriptionPayloadSubscription;
  likeOnComment: (
    where?: LikeOnCommentSubscriptionWhereInput
  ) => LikeOnCommentSubscriptionPayloadSubscription;
  meeting: (
    where?: MeetingSubscriptionWhereInput
  ) => MeetingSubscriptionPayloadSubscription;
  participant: (
    where?: ParticipantSubscriptionWhereInput
  ) => ParticipantSubscriptionPayloadSubscription;
  post: (
    where?: PostSubscriptionWhereInput
  ) => PostSubscriptionPayloadSubscription;
  reservation: (
    where?: ReservationSubscriptionWhereInput
  ) => ReservationSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  view: (
    where?: ViewSubscriptionWhereInput
  ) => ViewSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ReservationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type FileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "url_ASC"
  | "url_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type LikeOnCommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "avatar_ASC"
  | "avatar_DESC"
  | "userName_ASC"
  | "userName_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "phoneNum_ASC"
  | "phoneNum_DESC"
  | "email_ASC"
  | "email_DESC"
  | "introduce_ASC"
  | "introduce_DESC"
  | "password_ASC"
  | "password_DESC"
  | "classes_ASC"
  | "classes_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type PostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "classifyNum_ASC"
  | "classifyNum_DESC"
  | "main_ASC"
  | "main_DESC"
  | "announcement_ASC"
  | "announcement_DESC"
  | "title_ASC"
  | "title_DESC"
  | "caption_ASC"
  | "caption_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MeetingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "main_ASC"
  | "main_DESC"
  | "meetingTime_ASC"
  | "meetingTime_DESC"
  | "meetingPlace_ASC"
  | "meetingPlace_DESC"
  | "meetingPrice_ASC"
  | "meetingPrice_DESC"
  | "deadline_ASC"
  | "deadline_DESC"
  | "meetingHeadCounts_ASC"
  | "meetingHeadCounts_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type ParticipantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type BulletinListOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "classifyNum_ASC"
  | "classifyNum_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type LikeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type ViewOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type BookOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "author_ASC"
  | "author_DESC"
  | "publisher_ASC"
  | "publisher_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export interface UserUpdateOneWithoutReservationsInput {
  create?: Maybe<UserCreateWithoutReservationsInput>;
  update?: Maybe<UserUpdateWithoutReservationsDataInput>;
  upsert?: Maybe<UserUpsertWithoutReservationsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type BookWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ViewUpdateWithWhereUniqueWithoutPostInput {
  where: ViewWhereUniqueInput;
  data: ViewUpdateWithoutPostDataInput;
}

export interface BookWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  photo_every?: Maybe<FileWhereInput>;
  photo_some?: Maybe<FileWhereInput>;
  photo_none?: Maybe<FileWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  author?: Maybe<String>;
  author_not?: Maybe<String>;
  author_in?: Maybe<String[] | String>;
  author_not_in?: Maybe<String[] | String>;
  author_lt?: Maybe<String>;
  author_lte?: Maybe<String>;
  author_gt?: Maybe<String>;
  author_gte?: Maybe<String>;
  author_contains?: Maybe<String>;
  author_not_contains?: Maybe<String>;
  author_starts_with?: Maybe<String>;
  author_not_starts_with?: Maybe<String>;
  author_ends_with?: Maybe<String>;
  author_not_ends_with?: Maybe<String>;
  publisher?: Maybe<String>;
  publisher_not?: Maybe<String>;
  publisher_in?: Maybe<String[] | String>;
  publisher_not_in?: Maybe<String[] | String>;
  publisher_lt?: Maybe<String>;
  publisher_lte?: Maybe<String>;
  publisher_gt?: Maybe<String>;
  publisher_gte?: Maybe<String>;
  publisher_contains?: Maybe<String>;
  publisher_not_contains?: Maybe<String>;
  publisher_starts_with?: Maybe<String>;
  publisher_not_starts_with?: Maybe<String>;
  publisher_ends_with?: Maybe<String>;
  publisher_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  reservations_every?: Maybe<ReservationWhereInput>;
  reservations_some?: Maybe<ReservationWhereInput>;
  reservations_none?: Maybe<ReservationWhereInput>;
  AND?: Maybe<BookWhereInput[] | BookWhereInput>;
  OR?: Maybe<BookWhereInput[] | BookWhereInput>;
  NOT?: Maybe<BookWhereInput[] | BookWhereInput>;
}

export interface ViewUpdateWithoutPostDataInput {
  users?: Maybe<UserUpdateOneInput>;
}

export interface ViewWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  users?: Maybe<UserWhereInput>;
  post?: Maybe<PostWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ViewWhereInput[] | ViewWhereInput>;
  OR?: Maybe<ViewWhereInput[] | ViewWhereInput>;
  NOT?: Maybe<ViewWhereInput[] | ViewWhereInput>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ReservationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  book?: Maybe<BookWhereInput>;
  startDate?: Maybe<String>;
  startDate_not?: Maybe<String>;
  startDate_in?: Maybe<String[] | String>;
  startDate_not_in?: Maybe<String[] | String>;
  startDate_lt?: Maybe<String>;
  startDate_lte?: Maybe<String>;
  startDate_gt?: Maybe<String>;
  startDate_gte?: Maybe<String>;
  startDate_contains?: Maybe<String>;
  startDate_not_contains?: Maybe<String>;
  startDate_starts_with?: Maybe<String>;
  startDate_not_starts_with?: Maybe<String>;
  startDate_ends_with?: Maybe<String>;
  startDate_not_ends_with?: Maybe<String>;
  endDate?: Maybe<String>;
  endDate_not?: Maybe<String>;
  endDate_in?: Maybe<String[] | String>;
  endDate_not_in?: Maybe<String[] | String>;
  endDate_lt?: Maybe<String>;
  endDate_lte?: Maybe<String>;
  endDate_gt?: Maybe<String>;
  endDate_gte?: Maybe<String>;
  endDate_contains?: Maybe<String>;
  endDate_not_contains?: Maybe<String>;
  endDate_starts_with?: Maybe<String>;
  endDate_not_starts_with?: Maybe<String>;
  endDate_ends_with?: Maybe<String>;
  endDate_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReservationWhereInput[] | ReservationWhereInput>;
  OR?: Maybe<ReservationWhereInput[] | ReservationWhereInput>;
  NOT?: Maybe<ReservationWhereInput[] | ReservationWhereInput>;
}

export interface UserUpdateDataInput {
  avatar?: Maybe<String>;
  userName?: Maybe<String>;
  birthday?: Maybe<String>;
  phoneNum?: Maybe<String>;
  email?: Maybe<String>;
  introduce?: Maybe<String>;
  password?: Maybe<String>;
  classes?: Maybe<Int>;
  meetings?: Maybe<MeetingUpdateManyWithoutUserInput>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  reservations?: Maybe<ReservationUpdateManyWithoutUserInput>;
  likes?: Maybe<LikeUpdateManyWithoutUserInput>;
  participants?: Maybe<ParticipantUpdateManyWithoutUserInput>;
}

export interface LikeOnCommentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  comment?: Maybe<CommentWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<LikeOnCommentWhereInput[] | LikeOnCommentWhereInput>;
  OR?: Maybe<LikeOnCommentWhereInput[] | LikeOnCommentWhereInput>;
  NOT?: Maybe<LikeOnCommentWhereInput[] | LikeOnCommentWhereInput>;
}

export interface FileUpdateWithWhereUniqueWithoutBookInput {
  where: FileWhereUniqueInput;
  data: FileUpdateWithoutBookDataInput;
}

export interface PostCreateManyWithoutBulletinListInput {
  create?: Maybe<
    PostCreateWithoutBulletinListInput[] | PostCreateWithoutBulletinListInput
  >;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
}

export interface FileUpdateWithoutBookDataInput {
  url?: Maybe<String>;
  post?: Maybe<PostUpdateManyWithoutFilesInput>;
}

export interface ReservationUpdateManyWithoutUserInput {
  create?: Maybe<
    ReservationCreateWithoutUserInput[] | ReservationCreateWithoutUserInput
  >;
  delete?: Maybe<ReservationWhereUniqueInput[] | ReservationWhereUniqueInput>;
  connect?: Maybe<ReservationWhereUniqueInput[] | ReservationWhereUniqueInput>;
  set?: Maybe<ReservationWhereUniqueInput[] | ReservationWhereUniqueInput>;
  disconnect?: Maybe<
    ReservationWhereUniqueInput[] | ReservationWhereUniqueInput
  >;
  update?: Maybe<
    | ReservationUpdateWithWhereUniqueWithoutUserInput[]
    | ReservationUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | ReservationUpsertWithWhereUniqueWithoutUserInput[]
    | ReservationUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    ReservationScalarWhereInput[] | ReservationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ReservationUpdateManyWithWhereNestedInput[]
    | ReservationUpdateManyWithWhereNestedInput
  >;
}

export interface PostUpdateManyWithoutFilesInput {
  create?: Maybe<PostCreateWithoutFilesInput[] | PostCreateWithoutFilesInput>;
  delete?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  set?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  disconnect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  update?: Maybe<
    | PostUpdateWithWhereUniqueWithoutFilesInput[]
    | PostUpdateWithWhereUniqueWithoutFilesInput
  >;
  upsert?: Maybe<
    | PostUpsertWithWhereUniqueWithoutFilesInput[]
    | PostUpsertWithWhereUniqueWithoutFilesInput
  >;
  deleteMany?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  updateMany?: Maybe<
    PostUpdateManyWithWhereNestedInput[] | PostUpdateManyWithWhereNestedInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface PostUpdateWithWhereUniqueWithoutFilesInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutFilesDataInput;
}

export interface ParticipantWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  meeting?: Maybe<MeetingWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ParticipantWhereInput[] | ParticipantWhereInput>;
  OR?: Maybe<ParticipantWhereInput[] | ParticipantWhereInput>;
  NOT?: Maybe<ParticipantWhereInput[] | ParticipantWhereInput>;
}

export interface PostUpdateWithoutFilesDataInput {
  author?: Maybe<UserUpdateOneWithoutPostsInput>;
  classifyNum?: Maybe<Int>;
  main?: Maybe<Boolean>;
  announcement?: Maybe<Boolean>;
  title?: Maybe<String>;
  caption?: Maybe<String>;
  views?: Maybe<ViewUpdateManyWithoutPostInput>;
  likes?: Maybe<LikeUpdateManyWithoutPostInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostInput>;
  bulletinList?: Maybe<BulletinListUpdateOneRequiredWithoutPostsInput>;
}

export interface ParticipantSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ParticipantWhereInput>;
  AND?: Maybe<
    ParticipantSubscriptionWhereInput[] | ParticipantSubscriptionWhereInput
  >;
  OR?: Maybe<
    ParticipantSubscriptionWhereInput[] | ParticipantSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ParticipantSubscriptionWhereInput[] | ParticipantSubscriptionWhereInput
  >;
}

export interface UserUpdateOneWithoutPostsInput {
  create?: Maybe<UserCreateWithoutPostsInput>;
  update?: Maybe<UserUpdateWithoutPostsDataInput>;
  upsert?: Maybe<UserUpsertWithoutPostsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface MeetingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  main?: Maybe<Boolean>;
  main_not?: Maybe<Boolean>;
  user?: Maybe<UserWhereInput>;
  meetingTime?: Maybe<String>;
  meetingTime_not?: Maybe<String>;
  meetingTime_in?: Maybe<String[] | String>;
  meetingTime_not_in?: Maybe<String[] | String>;
  meetingTime_lt?: Maybe<String>;
  meetingTime_lte?: Maybe<String>;
  meetingTime_gt?: Maybe<String>;
  meetingTime_gte?: Maybe<String>;
  meetingTime_contains?: Maybe<String>;
  meetingTime_not_contains?: Maybe<String>;
  meetingTime_starts_with?: Maybe<String>;
  meetingTime_not_starts_with?: Maybe<String>;
  meetingTime_ends_with?: Maybe<String>;
  meetingTime_not_ends_with?: Maybe<String>;
  meetingPlace?: Maybe<String>;
  meetingPlace_not?: Maybe<String>;
  meetingPlace_in?: Maybe<String[] | String>;
  meetingPlace_not_in?: Maybe<String[] | String>;
  meetingPlace_lt?: Maybe<String>;
  meetingPlace_lte?: Maybe<String>;
  meetingPlace_gt?: Maybe<String>;
  meetingPlace_gte?: Maybe<String>;
  meetingPlace_contains?: Maybe<String>;
  meetingPlace_not_contains?: Maybe<String>;
  meetingPlace_starts_with?: Maybe<String>;
  meetingPlace_not_starts_with?: Maybe<String>;
  meetingPlace_ends_with?: Maybe<String>;
  meetingPlace_not_ends_with?: Maybe<String>;
  meetingPrice?: Maybe<String>;
  meetingPrice_not?: Maybe<String>;
  meetingPrice_in?: Maybe<String[] | String>;
  meetingPrice_not_in?: Maybe<String[] | String>;
  meetingPrice_lt?: Maybe<String>;
  meetingPrice_lte?: Maybe<String>;
  meetingPrice_gt?: Maybe<String>;
  meetingPrice_gte?: Maybe<String>;
  meetingPrice_contains?: Maybe<String>;
  meetingPrice_not_contains?: Maybe<String>;
  meetingPrice_starts_with?: Maybe<String>;
  meetingPrice_not_starts_with?: Maybe<String>;
  meetingPrice_ends_with?: Maybe<String>;
  meetingPrice_not_ends_with?: Maybe<String>;
  deadline?: Maybe<String>;
  deadline_not?: Maybe<String>;
  deadline_in?: Maybe<String[] | String>;
  deadline_not_in?: Maybe<String[] | String>;
  deadline_lt?: Maybe<String>;
  deadline_lte?: Maybe<String>;
  deadline_gt?: Maybe<String>;
  deadline_gte?: Maybe<String>;
  deadline_contains?: Maybe<String>;
  deadline_not_contains?: Maybe<String>;
  deadline_starts_with?: Maybe<String>;
  deadline_not_starts_with?: Maybe<String>;
  deadline_ends_with?: Maybe<String>;
  deadline_not_ends_with?: Maybe<String>;
  meetingHeadCounts?: Maybe<Int>;
  meetingHeadCounts_not?: Maybe<Int>;
  meetingHeadCounts_in?: Maybe<Int[] | Int>;
  meetingHeadCounts_not_in?: Maybe<Int[] | Int>;
  meetingHeadCounts_lt?: Maybe<Int>;
  meetingHeadCounts_lte?: Maybe<Int>;
  meetingHeadCounts_gt?: Maybe<Int>;
  meetingHeadCounts_gte?: Maybe<Int>;
  participants_every?: Maybe<ParticipantWhereInput>;
  participants_some?: Maybe<ParticipantWhereInput>;
  participants_none?: Maybe<ParticipantWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MeetingWhereInput[] | MeetingWhereInput>;
  OR?: Maybe<MeetingWhereInput[] | MeetingWhereInput>;
  NOT?: Maybe<MeetingWhereInput[] | MeetingWhereInput>;
}

export interface UserUpdateWithoutPostsDataInput {
  avatar?: Maybe<String>;
  userName?: Maybe<String>;
  birthday?: Maybe<String>;
  phoneNum?: Maybe<String>;
  email?: Maybe<String>;
  introduce?: Maybe<String>;
  password?: Maybe<String>;
  classes?: Maybe<Int>;
  meetings?: Maybe<MeetingUpdateManyWithoutUserInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  reservations?: Maybe<ReservationUpdateManyWithoutUserInput>;
  likes?: Maybe<LikeUpdateManyWithoutUserInput>;
  participants?: Maybe<ParticipantUpdateManyWithoutUserInput>;
}

export interface LikeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LikeWhereInput>;
  AND?: Maybe<LikeSubscriptionWhereInput[] | LikeSubscriptionWhereInput>;
  OR?: Maybe<LikeSubscriptionWhereInput[] | LikeSubscriptionWhereInput>;
  NOT?: Maybe<LikeSubscriptionWhereInput[] | LikeSubscriptionWhereInput>;
}

export interface MeetingUpdateManyWithoutUserInput {
  create?: Maybe<
    MeetingCreateWithoutUserInput[] | MeetingCreateWithoutUserInput
  >;
  delete?: Maybe<MeetingWhereUniqueInput[] | MeetingWhereUniqueInput>;
  connect?: Maybe<MeetingWhereUniqueInput[] | MeetingWhereUniqueInput>;
  set?: Maybe<MeetingWhereUniqueInput[] | MeetingWhereUniqueInput>;
  disconnect?: Maybe<MeetingWhereUniqueInput[] | MeetingWhereUniqueInput>;
  update?: Maybe<
    | MeetingUpdateWithWhereUniqueWithoutUserInput[]
    | MeetingUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | MeetingUpsertWithWhereUniqueWithoutUserInput[]
    | MeetingUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<MeetingScalarWhereInput[] | MeetingScalarWhereInput>;
  updateMany?: Maybe<
    | MeetingUpdateManyWithWhereNestedInput[]
    | MeetingUpdateManyWithWhereNestedInput
  >;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  avatar?: Maybe<String>;
  avatar_not?: Maybe<String>;
  avatar_in?: Maybe<String[] | String>;
  avatar_not_in?: Maybe<String[] | String>;
  avatar_lt?: Maybe<String>;
  avatar_lte?: Maybe<String>;
  avatar_gt?: Maybe<String>;
  avatar_gte?: Maybe<String>;
  avatar_contains?: Maybe<String>;
  avatar_not_contains?: Maybe<String>;
  avatar_starts_with?: Maybe<String>;
  avatar_not_starts_with?: Maybe<String>;
  avatar_ends_with?: Maybe<String>;
  avatar_not_ends_with?: Maybe<String>;
  userName?: Maybe<String>;
  userName_not?: Maybe<String>;
  userName_in?: Maybe<String[] | String>;
  userName_not_in?: Maybe<String[] | String>;
  userName_lt?: Maybe<String>;
  userName_lte?: Maybe<String>;
  userName_gt?: Maybe<String>;
  userName_gte?: Maybe<String>;
  userName_contains?: Maybe<String>;
  userName_not_contains?: Maybe<String>;
  userName_starts_with?: Maybe<String>;
  userName_not_starts_with?: Maybe<String>;
  userName_ends_with?: Maybe<String>;
  userName_not_ends_with?: Maybe<String>;
  birthday?: Maybe<String>;
  birthday_not?: Maybe<String>;
  birthday_in?: Maybe<String[] | String>;
  birthday_not_in?: Maybe<String[] | String>;
  birthday_lt?: Maybe<String>;
  birthday_lte?: Maybe<String>;
  birthday_gt?: Maybe<String>;
  birthday_gte?: Maybe<String>;
  birthday_contains?: Maybe<String>;
  birthday_not_contains?: Maybe<String>;
  birthday_starts_with?: Maybe<String>;
  birthday_not_starts_with?: Maybe<String>;
  birthday_ends_with?: Maybe<String>;
  birthday_not_ends_with?: Maybe<String>;
  phoneNum?: Maybe<String>;
  phoneNum_not?: Maybe<String>;
  phoneNum_in?: Maybe<String[] | String>;
  phoneNum_not_in?: Maybe<String[] | String>;
  phoneNum_lt?: Maybe<String>;
  phoneNum_lte?: Maybe<String>;
  phoneNum_gt?: Maybe<String>;
  phoneNum_gte?: Maybe<String>;
  phoneNum_contains?: Maybe<String>;
  phoneNum_not_contains?: Maybe<String>;
  phoneNum_starts_with?: Maybe<String>;
  phoneNum_not_starts_with?: Maybe<String>;
  phoneNum_ends_with?: Maybe<String>;
  phoneNum_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  introduce?: Maybe<String>;
  introduce_not?: Maybe<String>;
  introduce_in?: Maybe<String[] | String>;
  introduce_not_in?: Maybe<String[] | String>;
  introduce_lt?: Maybe<String>;
  introduce_lte?: Maybe<String>;
  introduce_gt?: Maybe<String>;
  introduce_gte?: Maybe<String>;
  introduce_contains?: Maybe<String>;
  introduce_not_contains?: Maybe<String>;
  introduce_starts_with?: Maybe<String>;
  introduce_not_starts_with?: Maybe<String>;
  introduce_ends_with?: Maybe<String>;
  introduce_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  classes?: Maybe<Int>;
  classes_not?: Maybe<Int>;
  classes_in?: Maybe<Int[] | Int>;
  classes_not_in?: Maybe<Int[] | Int>;
  classes_lt?: Maybe<Int>;
  classes_lte?: Maybe<Int>;
  classes_gt?: Maybe<Int>;
  classes_gte?: Maybe<Int>;
  meetings_every?: Maybe<MeetingWhereInput>;
  meetings_some?: Maybe<MeetingWhereInput>;
  meetings_none?: Maybe<MeetingWhereInput>;
  posts_every?: Maybe<PostWhereInput>;
  posts_some?: Maybe<PostWhereInput>;
  posts_none?: Maybe<PostWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  reservations_every?: Maybe<ReservationWhereInput>;
  reservations_some?: Maybe<ReservationWhereInput>;
  reservations_none?: Maybe<ReservationWhereInput>;
  likes_every?: Maybe<LikeWhereInput>;
  likes_some?: Maybe<LikeWhereInput>;
  likes_none?: Maybe<LikeWhereInput>;
  participants_every?: Maybe<ParticipantWhereInput>;
  participants_some?: Maybe<ParticipantWhereInput>;
  participants_none?: Maybe<ParticipantWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface MeetingUpdateWithWhereUniqueWithoutUserInput {
  where: MeetingWhereUniqueInput;
  data: MeetingUpdateWithoutUserDataInput;
}

export interface BulletinListSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BulletinListWhereInput>;
  AND?: Maybe<
    BulletinListSubscriptionWhereInput[] | BulletinListSubscriptionWhereInput
  >;
  OR?: Maybe<
    BulletinListSubscriptionWhereInput[] | BulletinListSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BulletinListSubscriptionWhereInput[] | BulletinListSubscriptionWhereInput
  >;
}

export interface MeetingUpdateWithoutUserDataInput {
  title?: Maybe<String>;
  main?: Maybe<Boolean>;
  meetingTime?: Maybe<String>;
  meetingPlace?: Maybe<String>;
  meetingPrice?: Maybe<String>;
  deadline?: Maybe<String>;
  meetingHeadCounts?: Maybe<Int>;
  participants?: Maybe<ParticipantUpdateManyWithoutMeetingInput>;
}

export interface BookSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BookWhereInput>;
  AND?: Maybe<BookSubscriptionWhereInput[] | BookSubscriptionWhereInput>;
  OR?: Maybe<BookSubscriptionWhereInput[] | BookSubscriptionWhereInput>;
  NOT?: Maybe<BookSubscriptionWhereInput[] | BookSubscriptionWhereInput>;
}

export interface ParticipantUpdateManyWithoutMeetingInput {
  create?: Maybe<
    | ParticipantCreateWithoutMeetingInput[]
    | ParticipantCreateWithoutMeetingInput
  >;
  delete?: Maybe<ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput>;
  connect?: Maybe<ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput>;
  set?: Maybe<ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput>;
  disconnect?: Maybe<
    ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput
  >;
  update?: Maybe<
    | ParticipantUpdateWithWhereUniqueWithoutMeetingInput[]
    | ParticipantUpdateWithWhereUniqueWithoutMeetingInput
  >;
  upsert?: Maybe<
    | ParticipantUpsertWithWhereUniqueWithoutMeetingInput[]
    | ParticipantUpsertWithWhereUniqueWithoutMeetingInput
  >;
  deleteMany?: Maybe<
    ParticipantScalarWhereInput[] | ParticipantScalarWhereInput
  >;
}

export interface PostUpdateWithoutViewsDataInput {
  files?: Maybe<FileUpdateManyWithoutPostInput>;
  author?: Maybe<UserUpdateOneWithoutPostsInput>;
  classifyNum?: Maybe<Int>;
  main?: Maybe<Boolean>;
  announcement?: Maybe<Boolean>;
  title?: Maybe<String>;
  caption?: Maybe<String>;
  likes?: Maybe<LikeUpdateManyWithoutPostInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostInput>;
  bulletinList?: Maybe<BulletinListUpdateOneRequiredWithoutPostsInput>;
}

export interface ParticipantUpdateWithWhereUniqueWithoutMeetingInput {
  where: ParticipantWhereUniqueInput;
  data: ParticipantUpdateWithoutMeetingDataInput;
}

export type BulletinListWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ParticipantUpdateWithoutMeetingDataInput {
  user?: Maybe<UserUpdateOneWithoutParticipantsInput>;
}

export interface PostCreateWithoutViewsInput {
  id?: Maybe<ID_Input>;
  files?: Maybe<FileCreateManyWithoutPostInput>;
  author?: Maybe<UserCreateOneWithoutPostsInput>;
  classifyNum: Int;
  main: Boolean;
  announcement: Boolean;
  title: String;
  caption: String;
  likes?: Maybe<LikeCreateManyWithoutPostInput>;
  comments?: Maybe<CommentCreateManyWithoutPostInput>;
  bulletinList: BulletinListCreateOneWithoutPostsInput;
}

export interface UserUpdateOneWithoutParticipantsInput {
  create?: Maybe<UserCreateWithoutParticipantsInput>;
  update?: Maybe<UserUpdateWithoutParticipantsDataInput>;
  upsert?: Maybe<UserUpsertWithoutParticipantsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ViewCreateInput {
  id?: Maybe<ID_Input>;
  users?: Maybe<UserCreateOneInput>;
  post: PostCreateOneWithoutViewsInput;
}

export interface UserUpdateWithoutParticipantsDataInput {
  avatar?: Maybe<String>;
  userName?: Maybe<String>;
  birthday?: Maybe<String>;
  phoneNum?: Maybe<String>;
  email?: Maybe<String>;
  introduce?: Maybe<String>;
  password?: Maybe<String>;
  classes?: Maybe<Int>;
  meetings?: Maybe<MeetingUpdateManyWithoutUserInput>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  reservations?: Maybe<ReservationUpdateManyWithoutUserInput>;
  likes?: Maybe<LikeUpdateManyWithoutUserInput>;
}

export interface UserUpdateManyMutationInput {
  avatar?: Maybe<String>;
  userName?: Maybe<String>;
  birthday?: Maybe<String>;
  phoneNum?: Maybe<String>;
  email?: Maybe<String>;
  introduce?: Maybe<String>;
  password?: Maybe<String>;
  classes?: Maybe<Int>;
}

export interface PostUpdateManyWithoutAuthorInput {
  create?: Maybe<PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput>;
  delete?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  set?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  disconnect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  update?: Maybe<
    | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    | PostUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    | PostUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  updateMany?: Maybe<
    PostUpdateManyWithWhereNestedInput[] | PostUpdateManyWithWhereNestedInput
  >;
}

export interface ReservationUpdateManyMutationInput {
  startDate?: Maybe<String>;
  endDate?: Maybe<String>;
}

export interface PostUpdateWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutAuthorDataInput;
}

export interface ReservationUpdateInput {
  user?: Maybe<UserUpdateOneWithoutReservationsInput>;
  book?: Maybe<BookUpdateOneRequiredWithoutReservationsInput>;
  startDate?: Maybe<String>;
  endDate?: Maybe<String>;
}

export interface PostUpdateWithoutAuthorDataInput {
  files?: Maybe<FileUpdateManyWithoutPostInput>;
  classifyNum?: Maybe<Int>;
  main?: Maybe<Boolean>;
  announcement?: Maybe<Boolean>;
  title?: Maybe<String>;
  caption?: Maybe<String>;
  views?: Maybe<ViewUpdateManyWithoutPostInput>;
  likes?: Maybe<LikeUpdateManyWithoutPostInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostInput>;
  bulletinList?: Maybe<BulletinListUpdateOneRequiredWithoutPostsInput>;
}

export interface PostUpdateManyMutationInput {
  classifyNum?: Maybe<Int>;
  main?: Maybe<Boolean>;
  announcement?: Maybe<Boolean>;
  title?: Maybe<String>;
  caption?: Maybe<String>;
}

export interface FileUpdateManyWithoutPostInput {
  create?: Maybe<FileCreateWithoutPostInput[] | FileCreateWithoutPostInput>;
  delete?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  connect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  set?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  disconnect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  update?: Maybe<
    | FileUpdateWithWhereUniqueWithoutPostInput[]
    | FileUpdateWithWhereUniqueWithoutPostInput
  >;
  upsert?: Maybe<
    | FileUpsertWithWhereUniqueWithoutPostInput[]
    | FileUpsertWithWhereUniqueWithoutPostInput
  >;
  deleteMany?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
  updateMany?: Maybe<
    FileUpdateManyWithWhereNestedInput[] | FileUpdateManyWithWhereNestedInput
  >;
}

export interface PostUpdateInput {
  files?: Maybe<FileUpdateManyWithoutPostInput>;
  author?: Maybe<UserUpdateOneWithoutPostsInput>;
  classifyNum?: Maybe<Int>;
  main?: Maybe<Boolean>;
  announcement?: Maybe<Boolean>;
  title?: Maybe<String>;
  caption?: Maybe<String>;
  views?: Maybe<ViewUpdateManyWithoutPostInput>;
  likes?: Maybe<LikeUpdateManyWithoutPostInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostInput>;
  bulletinList?: Maybe<BulletinListUpdateOneRequiredWithoutPostsInput>;
}

export interface FileUpdateWithWhereUniqueWithoutPostInput {
  where: FileWhereUniqueInput;
  data: FileUpdateWithoutPostDataInput;
}

export interface ParticipantUpdateInput {
  user?: Maybe<UserUpdateOneWithoutParticipantsInput>;
  meeting?: Maybe<MeetingUpdateOneRequiredWithoutParticipantsInput>;
}

export interface FileUpdateWithoutPostDataInput {
  url?: Maybe<String>;
  book?: Maybe<BookUpdateManyWithoutPhotoInput>;
}

export interface ParticipantCreateInput {
  id?: Maybe<ID_Input>;
  user?: Maybe<UserCreateOneWithoutParticipantsInput>;
  meeting: MeetingCreateOneWithoutParticipantsInput;
}

export interface BookUpdateManyWithoutPhotoInput {
  create?: Maybe<BookCreateWithoutPhotoInput[] | BookCreateWithoutPhotoInput>;
  delete?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  connect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  set?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  disconnect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  update?: Maybe<
    | BookUpdateWithWhereUniqueWithoutPhotoInput[]
    | BookUpdateWithWhereUniqueWithoutPhotoInput
  >;
  upsert?: Maybe<
    | BookUpsertWithWhereUniqueWithoutPhotoInput[]
    | BookUpsertWithWhereUniqueWithoutPhotoInput
  >;
  deleteMany?: Maybe<BookScalarWhereInput[] | BookScalarWhereInput>;
  updateMany?: Maybe<
    BookUpdateManyWithWhereNestedInput[] | BookUpdateManyWithWhereNestedInput
  >;
}

export interface MeetingUpdateInput {
  title?: Maybe<String>;
  main?: Maybe<Boolean>;
  user?: Maybe<UserUpdateOneWithoutMeetingsInput>;
  meetingTime?: Maybe<String>;
  meetingPlace?: Maybe<String>;
  meetingPrice?: Maybe<String>;
  deadline?: Maybe<String>;
  meetingHeadCounts?: Maybe<Int>;
  participants?: Maybe<ParticipantUpdateManyWithoutMeetingInput>;
}

export interface BookUpdateWithWhereUniqueWithoutPhotoInput {
  where: BookWhereUniqueInput;
  data: BookUpdateWithoutPhotoDataInput;
}

export interface MeetingCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  main: Boolean;
  user?: Maybe<UserCreateOneWithoutMeetingsInput>;
  meetingTime: String;
  meetingPlace: String;
  meetingPrice: String;
  deadline: String;
  meetingHeadCounts: Int;
  participants?: Maybe<ParticipantCreateManyWithoutMeetingInput>;
}

export interface BookUpdateWithoutPhotoDataInput {
  title?: Maybe<String>;
  author?: Maybe<String>;
  publisher?: Maybe<String>;
  content?: Maybe<String>;
  reservations?: Maybe<ReservationUpdateManyWithoutBookInput>;
}

export interface CommentUpdateWithoutLikesDataInput {
  text?: Maybe<String>;
  user?: Maybe<UserUpdateOneWithoutCommentsInput>;
  post?: Maybe<PostUpdateOneRequiredWithoutCommentsInput>;
}

export interface ReservationUpdateManyWithoutBookInput {
  create?: Maybe<
    ReservationCreateWithoutBookInput[] | ReservationCreateWithoutBookInput
  >;
  delete?: Maybe<ReservationWhereUniqueInput[] | ReservationWhereUniqueInput>;
  connect?: Maybe<ReservationWhereUniqueInput[] | ReservationWhereUniqueInput>;
  set?: Maybe<ReservationWhereUniqueInput[] | ReservationWhereUniqueInput>;
  disconnect?: Maybe<
    ReservationWhereUniqueInput[] | ReservationWhereUniqueInput
  >;
  update?: Maybe<
    | ReservationUpdateWithWhereUniqueWithoutBookInput[]
    | ReservationUpdateWithWhereUniqueWithoutBookInput
  >;
  upsert?: Maybe<
    | ReservationUpsertWithWhereUniqueWithoutBookInput[]
    | ReservationUpsertWithWhereUniqueWithoutBookInput
  >;
  deleteMany?: Maybe<
    ReservationScalarWhereInput[] | ReservationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ReservationUpdateManyWithWhereNestedInput[]
    | ReservationUpdateManyWithWhereNestedInput
  >;
}

export interface CommentUpdateOneRequiredWithoutLikesInput {
  create?: Maybe<CommentCreateWithoutLikesInput>;
  update?: Maybe<CommentUpdateWithoutLikesDataInput>;
  upsert?: Maybe<CommentUpsertWithoutLikesInput>;
  connect?: Maybe<CommentWhereUniqueInput>;
}

export interface ReservationUpdateWithWhereUniqueWithoutBookInput {
  where: ReservationWhereUniqueInput;
  data: ReservationUpdateWithoutBookDataInput;
}

export interface CommentCreateWithoutLikesInput {
  id?: Maybe<ID_Input>;
  text: String;
  user?: Maybe<UserCreateOneWithoutCommentsInput>;
  post: PostCreateOneWithoutCommentsInput;
}

export interface ReservationUpdateWithoutBookDataInput {
  user?: Maybe<UserUpdateOneWithoutReservationsInput>;
  startDate?: Maybe<String>;
  endDate?: Maybe<String>;
}

export interface CommentCreateOneWithoutLikesInput {
  create?: Maybe<CommentCreateWithoutLikesInput>;
  connect?: Maybe<CommentWhereUniqueInput>;
}

export interface PostUpdateWithoutBulletinListDataInput {
  files?: Maybe<FileUpdateManyWithoutPostInput>;
  author?: Maybe<UserUpdateOneWithoutPostsInput>;
  classifyNum?: Maybe<Int>;
  main?: Maybe<Boolean>;
  announcement?: Maybe<Boolean>;
  title?: Maybe<String>;
  caption?: Maybe<String>;
  views?: Maybe<ViewUpdateManyWithoutPostInput>;
  likes?: Maybe<LikeUpdateManyWithoutPostInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostInput>;
}

export interface LikeUpdateInput {
  user?: Maybe<UserUpdateOneWithoutLikesInput>;
  post?: Maybe<PostUpdateOneRequiredWithoutLikesInput>;
}

export interface UserUpdateWithoutReservationsDataInput {
  avatar?: Maybe<String>;
  userName?: Maybe<String>;
  birthday?: Maybe<String>;
  phoneNum?: Maybe<String>;
  email?: Maybe<String>;
  introduce?: Maybe<String>;
  password?: Maybe<String>;
  classes?: Maybe<Int>;
  meetings?: Maybe<MeetingUpdateManyWithoutUserInput>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  likes?: Maybe<LikeUpdateManyWithoutUserInput>;
  participants?: Maybe<ParticipantUpdateManyWithoutUserInput>;
}

export interface LikeCreateInput {
  id?: Maybe<ID_Input>;
  user?: Maybe<UserCreateOneWithoutLikesInput>;
  post: PostCreateOneWithoutLikesInput;
}

export interface CommentUpdateManyWithoutUserInput {
  create?: Maybe<
    CommentCreateWithoutUserInput[] | CommentCreateWithoutUserInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutUserInput[]
    | CommentUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutUserInput[]
    | CommentUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface FileUpdateInput {
  url?: Maybe<String>;
  post?: Maybe<PostUpdateManyWithoutFilesInput>;
  book?: Maybe<BookUpdateManyWithoutPhotoInput>;
}

export interface CommentUpdateWithWhereUniqueWithoutUserInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutUserDataInput;
}

export interface FileWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  post_every?: Maybe<PostWhereInput>;
  post_some?: Maybe<PostWhereInput>;
  post_none?: Maybe<PostWhereInput>;
  book_every?: Maybe<BookWhereInput>;
  book_some?: Maybe<BookWhereInput>;
  book_none?: Maybe<BookWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FileWhereInput[] | FileWhereInput>;
  OR?: Maybe<FileWhereInput[] | FileWhereInput>;
  NOT?: Maybe<FileWhereInput[] | FileWhereInput>;
}

export interface CommentUpdateWithoutUserDataInput {
  text?: Maybe<String>;
  post?: Maybe<PostUpdateOneRequiredWithoutCommentsInput>;
  likes?: Maybe<LikeOnCommentUpdateManyWithoutCommentInput>;
}

export interface CommentUpdateManyMutationInput {
  text?: Maybe<String>;
}

export interface PostUpdateOneRequiredWithoutCommentsInput {
  create?: Maybe<PostCreateWithoutCommentsInput>;
  update?: Maybe<PostUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<PostUpsertWithoutCommentsInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export type ViewWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PostUpdateWithoutCommentsDataInput {
  files?: Maybe<FileUpdateManyWithoutPostInput>;
  author?: Maybe<UserUpdateOneWithoutPostsInput>;
  classifyNum?: Maybe<Int>;
  main?: Maybe<Boolean>;
  announcement?: Maybe<Boolean>;
  title?: Maybe<String>;
  caption?: Maybe<String>;
  views?: Maybe<ViewUpdateManyWithoutPostInput>;
  likes?: Maybe<LikeUpdateManyWithoutPostInput>;
  bulletinList?: Maybe<BulletinListUpdateOneRequiredWithoutPostsInput>;
}

export interface BulletinListUpdateManyMutationInput {
  classifyNum?: Maybe<Int>;
}

export interface ViewUpdateManyWithoutPostInput {
  create?: Maybe<ViewCreateWithoutPostInput[] | ViewCreateWithoutPostInput>;
  delete?: Maybe<ViewWhereUniqueInput[] | ViewWhereUniqueInput>;
  connect?: Maybe<ViewWhereUniqueInput[] | ViewWhereUniqueInput>;
  set?: Maybe<ViewWhereUniqueInput[] | ViewWhereUniqueInput>;
  disconnect?: Maybe<ViewWhereUniqueInput[] | ViewWhereUniqueInput>;
  update?: Maybe<
    | ViewUpdateWithWhereUniqueWithoutPostInput[]
    | ViewUpdateWithWhereUniqueWithoutPostInput
  >;
  upsert?: Maybe<
    | ViewUpsertWithWhereUniqueWithoutPostInput[]
    | ViewUpsertWithWhereUniqueWithoutPostInput
  >;
  deleteMany?: Maybe<ViewScalarWhereInput[] | ViewScalarWhereInput>;
}

export interface FileCreateManyWithoutBookInput {
  create?: Maybe<FileCreateWithoutBookInput[] | FileCreateWithoutBookInput>;
  connect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
}

export interface LikeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  post?: Maybe<PostWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<LikeWhereInput[] | LikeWhereInput>;
  OR?: Maybe<LikeWhereInput[] | LikeWhereInput>;
  NOT?: Maybe<LikeWhereInput[] | LikeWhereInput>;
}

export interface PostCreateManyWithoutFilesInput {
  create?: Maybe<PostCreateWithoutFilesInput[] | PostCreateWithoutFilesInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
}

export interface BulletinListWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  classifyNum?: Maybe<Int>;
  classifyNum_not?: Maybe<Int>;
  classifyNum_in?: Maybe<Int[] | Int>;
  classifyNum_not_in?: Maybe<Int[] | Int>;
  classifyNum_lt?: Maybe<Int>;
  classifyNum_lte?: Maybe<Int>;
  classifyNum_gt?: Maybe<Int>;
  classifyNum_gte?: Maybe<Int>;
  posts_every?: Maybe<PostWhereInput>;
  posts_some?: Maybe<PostWhereInput>;
  posts_none?: Maybe<PostWhereInput>;
  AND?: Maybe<BulletinListWhereInput[] | BulletinListWhereInput>;
  OR?: Maybe<BulletinListWhereInput[] | BulletinListWhereInput>;
  NOT?: Maybe<BulletinListWhereInput[] | BulletinListWhereInput>;
}

export interface UserCreateOneWithoutPostsInput {
  create?: Maybe<UserCreateWithoutPostsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface PostUpdateWithWhereUniqueWithoutBulletinListInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutBulletinListDataInput;
}

export interface MeetingCreateManyWithoutUserInput {
  create?: Maybe<
    MeetingCreateWithoutUserInput[] | MeetingCreateWithoutUserInput
  >;
  connect?: Maybe<MeetingWhereUniqueInput[] | MeetingWhereUniqueInput>;
}

export interface PostUpdateManyWithoutBulletinListInput {
  create?: Maybe<
    PostCreateWithoutBulletinListInput[] | PostCreateWithoutBulletinListInput
  >;
  delete?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  set?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  disconnect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  update?: Maybe<
    | PostUpdateWithWhereUniqueWithoutBulletinListInput[]
    | PostUpdateWithWhereUniqueWithoutBulletinListInput
  >;
  upsert?: Maybe<
    | PostUpsertWithWhereUniqueWithoutBulletinListInput[]
    | PostUpsertWithWhereUniqueWithoutBulletinListInput
  >;
  deleteMany?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  updateMany?: Maybe<
    PostUpdateManyWithWhereNestedInput[] | PostUpdateManyWithWhereNestedInput
  >;
}

export interface ParticipantCreateManyWithoutMeetingInput {
  create?: Maybe<
    | ParticipantCreateWithoutMeetingInput[]
    | ParticipantCreateWithoutMeetingInput
  >;
  connect?: Maybe<ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput>;
}

export interface CommentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  post?: Maybe<PostWhereInput>;
  likes_every?: Maybe<LikeOnCommentWhereInput>;
  likes_some?: Maybe<LikeOnCommentWhereInput>;
  likes_none?: Maybe<LikeOnCommentWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  OR?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  NOT?: Maybe<CommentWhereInput[] | CommentWhereInput>;
}

export interface UserCreateOneWithoutParticipantsInput {
  create?: Maybe<UserCreateWithoutParticipantsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ReservationUpdateWithWhereUniqueWithoutUserInput {
  where: ReservationWhereUniqueInput;
  data: ReservationUpdateWithoutUserDataInput;
}

export interface PostCreateManyWithoutAuthorInput {
  create?: Maybe<PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
}

export interface ReservationUpdateWithoutUserDataInput {
  book?: Maybe<BookUpdateOneRequiredWithoutReservationsInput>;
  startDate?: Maybe<String>;
  endDate?: Maybe<String>;
}

export interface FileCreateManyWithoutPostInput {
  create?: Maybe<FileCreateWithoutPostInput[] | FileCreateWithoutPostInput>;
  connect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
}

export interface BookUpdateOneRequiredWithoutReservationsInput {
  create?: Maybe<BookCreateWithoutReservationsInput>;
  update?: Maybe<BookUpdateWithoutReservationsDataInput>;
  upsert?: Maybe<BookUpsertWithoutReservationsInput>;
  connect?: Maybe<BookWhereUniqueInput>;
}

export interface BookCreateManyWithoutPhotoInput {
  create?: Maybe<BookCreateWithoutPhotoInput[] | BookCreateWithoutPhotoInput>;
  connect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
}

export interface BookUpdateWithoutReservationsDataInput {
  photo?: Maybe<FileUpdateManyWithoutBookInput>;
  title?: Maybe<String>;
  author?: Maybe<String>;
  publisher?: Maybe<String>;
  content?: Maybe<String>;
}

export interface ReservationCreateManyWithoutBookInput {
  create?: Maybe<
    ReservationCreateWithoutBookInput[] | ReservationCreateWithoutBookInput
  >;
  connect?: Maybe<ReservationWhereUniqueInput[] | ReservationWhereUniqueInput>;
}

export interface BookUpsertWithoutReservationsInput {
  update: BookUpdateWithoutReservationsDataInput;
  create: BookCreateWithoutReservationsInput;
}

export interface UserCreateOneWithoutReservationsInput {
  create?: Maybe<UserCreateWithoutReservationsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ReservationUpsertWithWhereUniqueWithoutUserInput {
  where: ReservationWhereUniqueInput;
  update: ReservationUpdateWithoutUserDataInput;
  create: ReservationCreateWithoutUserInput;
}

export interface CommentCreateManyWithoutUserInput {
  create?: Maybe<
    CommentCreateWithoutUserInput[] | CommentCreateWithoutUserInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface ReservationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  startDate?: Maybe<String>;
  startDate_not?: Maybe<String>;
  startDate_in?: Maybe<String[] | String>;
  startDate_not_in?: Maybe<String[] | String>;
  startDate_lt?: Maybe<String>;
  startDate_lte?: Maybe<String>;
  startDate_gt?: Maybe<String>;
  startDate_gte?: Maybe<String>;
  startDate_contains?: Maybe<String>;
  startDate_not_contains?: Maybe<String>;
  startDate_starts_with?: Maybe<String>;
  startDate_not_starts_with?: Maybe<String>;
  startDate_ends_with?: Maybe<String>;
  startDate_not_ends_with?: Maybe<String>;
  endDate?: Maybe<String>;
  endDate_not?: Maybe<String>;
  endDate_in?: Maybe<String[] | String>;
  endDate_not_in?: Maybe<String[] | String>;
  endDate_lt?: Maybe<String>;
  endDate_lte?: Maybe<String>;
  endDate_gt?: Maybe<String>;
  endDate_gte?: Maybe<String>;
  endDate_contains?: Maybe<String>;
  endDate_not_contains?: Maybe<String>;
  endDate_starts_with?: Maybe<String>;
  endDate_not_starts_with?: Maybe<String>;
  endDate_ends_with?: Maybe<String>;
  endDate_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReservationScalarWhereInput[] | ReservationScalarWhereInput>;
  OR?: Maybe<ReservationScalarWhereInput[] | ReservationScalarWhereInput>;
  NOT?: Maybe<ReservationScalarWhereInput[] | ReservationScalarWhereInput>;
}

export interface PostCreateOneWithoutCommentsInput {
  create?: Maybe<PostCreateWithoutCommentsInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface ReservationUpdateManyWithWhereNestedInput {
  where: ReservationScalarWhereInput;
  data: ReservationUpdateManyDataInput;
}

export interface ViewCreateManyWithoutPostInput {
  create?: Maybe<ViewCreateWithoutPostInput[] | ViewCreateWithoutPostInput>;
  connect?: Maybe<ViewWhereUniqueInput[] | ViewWhereUniqueInput>;
}

export interface ReservationUpdateManyDataInput {
  startDate?: Maybe<String>;
  endDate?: Maybe<String>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface LikeUpdateManyWithoutUserInput {
  create?: Maybe<LikeCreateWithoutUserInput[] | LikeCreateWithoutUserInput>;
  delete?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
  connect?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
  set?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
  disconnect?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
  update?: Maybe<
    | LikeUpdateWithWhereUniqueWithoutUserInput[]
    | LikeUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | LikeUpsertWithWhereUniqueWithoutUserInput[]
    | LikeUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<LikeScalarWhereInput[] | LikeScalarWhereInput>;
}

export interface ReservationCreateManyWithoutUserInput {
  create?: Maybe<
    ReservationCreateWithoutUserInput[] | ReservationCreateWithoutUserInput
  >;
  connect?: Maybe<ReservationWhereUniqueInput[] | ReservationWhereUniqueInput>;
}

export interface LikeUpdateWithWhereUniqueWithoutUserInput {
  where: LikeWhereUniqueInput;
  data: LikeUpdateWithoutUserDataInput;
}

export interface BookCreateOneWithoutReservationsInput {
  create?: Maybe<BookCreateWithoutReservationsInput>;
  connect?: Maybe<BookWhereUniqueInput>;
}

export interface LikeUpdateWithoutUserDataInput {
  post?: Maybe<PostUpdateOneRequiredWithoutLikesInput>;
}

export interface LikeCreateManyWithoutUserInput {
  create?: Maybe<LikeCreateWithoutUserInput[] | LikeCreateWithoutUserInput>;
  connect?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
}

export interface PostUpdateOneRequiredWithoutLikesInput {
  create?: Maybe<PostCreateWithoutLikesInput>;
  update?: Maybe<PostUpdateWithoutLikesDataInput>;
  upsert?: Maybe<PostUpsertWithoutLikesInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface PostCreateOneWithoutLikesInput {
  create?: Maybe<PostCreateWithoutLikesInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface PostUpdateWithoutLikesDataInput {
  files?: Maybe<FileUpdateManyWithoutPostInput>;
  author?: Maybe<UserUpdateOneWithoutPostsInput>;
  classifyNum?: Maybe<Int>;
  main?: Maybe<Boolean>;
  announcement?: Maybe<Boolean>;
  title?: Maybe<String>;
  caption?: Maybe<String>;
  views?: Maybe<ViewUpdateManyWithoutPostInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostInput>;
  bulletinList?: Maybe<BulletinListUpdateOneRequiredWithoutPostsInput>;
}

export interface CommentCreateManyWithoutPostInput {
  create?: Maybe<
    CommentCreateWithoutPostInput[] | CommentCreateWithoutPostInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentUpdateManyWithoutPostInput {
  create?: Maybe<
    CommentCreateWithoutPostInput[] | CommentCreateWithoutPostInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutPostInput[]
    | CommentUpdateWithWhereUniqueWithoutPostInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutPostInput[]
    | CommentUpsertWithWhereUniqueWithoutPostInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateOneWithoutCommentsInput {
  create?: Maybe<UserCreateWithoutCommentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CommentUpdateWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutPostDataInput;
}

export interface ParticipantCreateManyWithoutUserInput {
  create?: Maybe<
    ParticipantCreateWithoutUserInput[] | ParticipantCreateWithoutUserInput
  >;
  connect?: Maybe<ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput>;
}

export interface CommentUpdateWithoutPostDataInput {
  text?: Maybe<String>;
  user?: Maybe<UserUpdateOneWithoutCommentsInput>;
  likes?: Maybe<LikeOnCommentUpdateManyWithoutCommentInput>;
}

export interface MeetingCreateOneWithoutParticipantsInput {
  create?: Maybe<MeetingCreateWithoutParticipantsInput>;
  connect?: Maybe<MeetingWhereUniqueInput>;
}

export interface UserUpdateOneWithoutCommentsInput {
  create?: Maybe<UserCreateWithoutCommentsInput>;
  update?: Maybe<UserUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<UserUpsertWithoutCommentsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateOneWithoutMeetingsInput {
  create?: Maybe<UserCreateWithoutMeetingsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutCommentsDataInput {
  avatar?: Maybe<String>;
  userName?: Maybe<String>;
  birthday?: Maybe<String>;
  phoneNum?: Maybe<String>;
  email?: Maybe<String>;
  introduce?: Maybe<String>;
  password?: Maybe<String>;
  classes?: Maybe<Int>;
  meetings?: Maybe<MeetingUpdateManyWithoutUserInput>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  reservations?: Maybe<ReservationUpdateManyWithoutUserInput>;
  likes?: Maybe<LikeUpdateManyWithoutUserInput>;
  participants?: Maybe<ParticipantUpdateManyWithoutUserInput>;
}

export interface LikeOnCommentCreateManyWithoutCommentInput {
  create?: Maybe<
    | LikeOnCommentCreateWithoutCommentInput[]
    | LikeOnCommentCreateWithoutCommentInput
  >;
  connect?: Maybe<
    LikeOnCommentWhereUniqueInput[] | LikeOnCommentWhereUniqueInput
  >;
}

export interface ParticipantUpdateManyWithoutUserInput {
  create?: Maybe<
    ParticipantCreateWithoutUserInput[] | ParticipantCreateWithoutUserInput
  >;
  delete?: Maybe<ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput>;
  connect?: Maybe<ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput>;
  set?: Maybe<ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput>;
  disconnect?: Maybe<
    ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput
  >;
  update?: Maybe<
    | ParticipantUpdateWithWhereUniqueWithoutUserInput[]
    | ParticipantUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | ParticipantUpsertWithWhereUniqueWithoutUserInput[]
    | ParticipantUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    ParticipantScalarWhereInput[] | ParticipantScalarWhereInput
  >;
}

export interface BulletinListCreateOneWithoutPostsInput {
  create?: Maybe<BulletinListCreateWithoutPostsInput>;
  connect?: Maybe<BulletinListWhereUniqueInput>;
}

export interface ParticipantUpdateWithWhereUniqueWithoutUserInput {
  where: ParticipantWhereUniqueInput;
  data: ParticipantUpdateWithoutUserDataInput;
}

export interface LikeCreateManyWithoutPostInput {
  create?: Maybe<LikeCreateWithoutPostInput[] | LikeCreateWithoutPostInput>;
  connect?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
}

export interface ParticipantUpdateWithoutUserDataInput {
  meeting?: Maybe<MeetingUpdateOneRequiredWithoutParticipantsInput>;
}

export interface UserCreateOneWithoutLikesInput {
  create?: Maybe<UserCreateWithoutLikesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface MeetingUpdateOneRequiredWithoutParticipantsInput {
  create?: Maybe<MeetingCreateWithoutParticipantsInput>;
  update?: Maybe<MeetingUpdateWithoutParticipantsDataInput>;
  upsert?: Maybe<MeetingUpsertWithoutParticipantsInput>;
  connect?: Maybe<MeetingWhereUniqueInput>;
}

export interface BookUpdateInput {
  photo?: Maybe<FileUpdateManyWithoutBookInput>;
  title?: Maybe<String>;
  author?: Maybe<String>;
  publisher?: Maybe<String>;
  content?: Maybe<String>;
  reservations?: Maybe<ReservationUpdateManyWithoutBookInput>;
}

export interface MeetingUpdateWithoutParticipantsDataInput {
  title?: Maybe<String>;
  main?: Maybe<Boolean>;
  user?: Maybe<UserUpdateOneWithoutMeetingsInput>;
  meetingTime?: Maybe<String>;
  meetingPlace?: Maybe<String>;
  meetingPrice?: Maybe<String>;
  deadline?: Maybe<String>;
  meetingHeadCounts?: Maybe<Int>;
}

export interface ViewSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ViewWhereInput>;
  AND?: Maybe<ViewSubscriptionWhereInput[] | ViewSubscriptionWhereInput>;
  OR?: Maybe<ViewSubscriptionWhereInput[] | ViewSubscriptionWhereInput>;
  NOT?: Maybe<ViewSubscriptionWhereInput[] | ViewSubscriptionWhereInput>;
}

export interface UserUpdateOneWithoutMeetingsInput {
  create?: Maybe<UserCreateWithoutMeetingsInput>;
  update?: Maybe<UserUpdateWithoutMeetingsDataInput>;
  upsert?: Maybe<UserUpsertWithoutMeetingsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PostWhereInput>;
  AND?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
  OR?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
  NOT?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
}

export interface UserUpdateWithoutMeetingsDataInput {
  avatar?: Maybe<String>;
  userName?: Maybe<String>;
  birthday?: Maybe<String>;
  phoneNum?: Maybe<String>;
  email?: Maybe<String>;
  introduce?: Maybe<String>;
  password?: Maybe<String>;
  classes?: Maybe<Int>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  reservations?: Maybe<ReservationUpdateManyWithoutUserInput>;
  likes?: Maybe<LikeUpdateManyWithoutUserInput>;
  participants?: Maybe<ParticipantUpdateManyWithoutUserInput>;
}

export interface LikeOnCommentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LikeOnCommentWhereInput>;
  AND?: Maybe<
    LikeOnCommentSubscriptionWhereInput[] | LikeOnCommentSubscriptionWhereInput
  >;
  OR?: Maybe<
    LikeOnCommentSubscriptionWhereInput[] | LikeOnCommentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    LikeOnCommentSubscriptionWhereInput[] | LikeOnCommentSubscriptionWhereInput
  >;
}

export interface UserUpsertWithoutMeetingsInput {
  update: UserUpdateWithoutMeetingsDataInput;
  create: UserCreateWithoutMeetingsInput;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommentWhereInput>;
  AND?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  OR?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  NOT?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
}

export interface MeetingUpsertWithoutParticipantsInput {
  update: MeetingUpdateWithoutParticipantsDataInput;
  create: MeetingCreateWithoutParticipantsInput;
}

export interface PostUpsertWithoutViewsInput {
  update: PostUpdateWithoutViewsDataInput;
  create: PostCreateWithoutViewsInput;
}

export interface ParticipantUpsertWithWhereUniqueWithoutUserInput {
  where: ParticipantWhereUniqueInput;
  update: ParticipantUpdateWithoutUserDataInput;
  create: ParticipantCreateWithoutUserInput;
}

export interface ViewUpdateInput {
  users?: Maybe<UserUpdateOneInput>;
  post?: Maybe<PostUpdateOneRequiredWithoutViewsInput>;
}

export interface ParticipantScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ParticipantScalarWhereInput[] | ParticipantScalarWhereInput>;
  OR?: Maybe<ParticipantScalarWhereInput[] | ParticipantScalarWhereInput>;
  NOT?: Maybe<ParticipantScalarWhereInput[] | ParticipantScalarWhereInput>;
}

export type CommentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsDataInput;
  create: UserCreateWithoutCommentsInput;
}

export type FileWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LikeOnCommentUpdateManyWithoutCommentInput {
  create?: Maybe<
    | LikeOnCommentCreateWithoutCommentInput[]
    | LikeOnCommentCreateWithoutCommentInput
  >;
  delete?: Maybe<
    LikeOnCommentWhereUniqueInput[] | LikeOnCommentWhereUniqueInput
  >;
  connect?: Maybe<
    LikeOnCommentWhereUniqueInput[] | LikeOnCommentWhereUniqueInput
  >;
  set?: Maybe<LikeOnCommentWhereUniqueInput[] | LikeOnCommentWhereUniqueInput>;
  disconnect?: Maybe<
    LikeOnCommentWhereUniqueInput[] | LikeOnCommentWhereUniqueInput
  >;
  update?: Maybe<
    | LikeOnCommentUpdateWithWhereUniqueWithoutCommentInput[]
    | LikeOnCommentUpdateWithWhereUniqueWithoutCommentInput
  >;
  upsert?: Maybe<
    | LikeOnCommentUpsertWithWhereUniqueWithoutCommentInput[]
    | LikeOnCommentUpsertWithWhereUniqueWithoutCommentInput
  >;
  deleteMany?: Maybe<
    LikeOnCommentScalarWhereInput[] | LikeOnCommentScalarWhereInput
  >;
}

export type LikeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LikeOnCommentUpdateWithWhereUniqueWithoutCommentInput {
  where: LikeOnCommentWhereUniqueInput;
  data: LikeOnCommentUpdateWithoutCommentDataInput;
}

export type LikeOnCommentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LikeOnCommentUpdateWithoutCommentDataInput {
  user?: Maybe<UserUpdateOneInput>;
}

export type MeetingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LikeOnCommentUpsertWithWhereUniqueWithoutCommentInput {
  where: LikeOnCommentWhereUniqueInput;
  update: LikeOnCommentUpdateWithoutCommentDataInput;
  create: LikeOnCommentCreateWithoutCommentInput;
}

export type ParticipantWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LikeOnCommentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<LikeOnCommentScalarWhereInput[] | LikeOnCommentScalarWhereInput>;
  OR?: Maybe<LikeOnCommentScalarWhereInput[] | LikeOnCommentScalarWhereInput>;
  NOT?: Maybe<LikeOnCommentScalarWhereInput[] | LikeOnCommentScalarWhereInput>;
}

export type PostWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CommentUpsertWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutPostDataInput;
  create: CommentCreateWithoutPostInput;
}

export type ReservationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CommentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  OR?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  NOT?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  phoneNum?: Maybe<String>;
  email?: Maybe<String>;
}>;

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export interface CommentUpdateInput {
  text?: Maybe<String>;
  user?: Maybe<UserUpdateOneWithoutCommentsInput>;
  post?: Maybe<PostUpdateOneRequiredWithoutCommentsInput>;
  likes?: Maybe<LikeOnCommentUpdateManyWithoutCommentInput>;
}

export interface CommentUpdateManyDataInput {
  text?: Maybe<String>;
}

export interface PostUpsertWithWhereUniqueWithoutBulletinListInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutBulletinListDataInput;
  create: PostCreateWithoutBulletinListInput;
}

export interface BulletinListUpdateOneRequiredWithoutPostsInput {
  create?: Maybe<BulletinListCreateWithoutPostsInput>;
  update?: Maybe<BulletinListUpdateWithoutPostsDataInput>;
  upsert?: Maybe<BulletinListUpsertWithoutPostsInput>;
  connect?: Maybe<BulletinListWhereUniqueInput>;
}

export interface FileCreateWithoutBookInput {
  id?: Maybe<ID_Input>;
  url: String;
  post?: Maybe<PostCreateManyWithoutFilesInput>;
}

export interface BulletinListUpdateWithoutPostsDataInput {
  classifyNum?: Maybe<Int>;
}

export interface UserCreateWithoutPostsInput {
  id?: Maybe<ID_Input>;
  avatar?: Maybe<String>;
  userName?: Maybe<String>;
  birthday?: Maybe<String>;
  phoneNum?: Maybe<String>;
  email: String;
  introduce?: Maybe<String>;
  password?: Maybe<String>;
  classes: Int;
  meetings?: Maybe<MeetingCreateManyWithoutUserInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
  reservations?: Maybe<ReservationCreateManyWithoutUserInput>;
  likes?: Maybe<LikeCreateManyWithoutUserInput>;
  participants?: Maybe<ParticipantCreateManyWithoutUserInput>;
}

export interface BulletinListUpsertWithoutPostsInput {
  update: BulletinListUpdateWithoutPostsDataInput;
  create: BulletinListCreateWithoutPostsInput;
}

export interface ParticipantCreateWithoutMeetingInput {
  id?: Maybe<ID_Input>;
  user?: Maybe<UserCreateOneWithoutParticipantsInput>;
}

export interface PostUpsertWithoutLikesInput {
  update: PostUpdateWithoutLikesDataInput;
  create: PostCreateWithoutLikesInput;
}

export interface PostCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  files?: Maybe<FileCreateManyWithoutPostInput>;
  classifyNum: Int;
  main: Boolean;
  announcement: Boolean;
  title: String;
  caption: String;
  views?: Maybe<ViewCreateManyWithoutPostInput>;
  likes?: Maybe<LikeCreateManyWithoutPostInput>;
  comments?: Maybe<CommentCreateManyWithoutPostInput>;
  bulletinList: BulletinListCreateOneWithoutPostsInput;
}

export interface LikeUpsertWithWhereUniqueWithoutUserInput {
  where: LikeWhereUniqueInput;
  update: LikeUpdateWithoutUserDataInput;
  create: LikeCreateWithoutUserInput;
}

export interface BookCreateWithoutPhotoInput {
  id?: Maybe<ID_Input>;
  title: String;
  author: String;
  publisher: String;
  content: String;
  reservations?: Maybe<ReservationCreateManyWithoutBookInput>;
}

export interface LikeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<LikeScalarWhereInput[] | LikeScalarWhereInput>;
  OR?: Maybe<LikeScalarWhereInput[] | LikeScalarWhereInput>;
  NOT?: Maybe<LikeScalarWhereInput[] | LikeScalarWhereInput>;
}

export interface UserCreateWithoutReservationsInput {
  id?: Maybe<ID_Input>;
  avatar?: Maybe<String>;
  userName?: Maybe<String>;
  birthday?: Maybe<String>;
  phoneNum?: Maybe<String>;
  email: String;
  introduce?: Maybe<String>;
  password?: Maybe<String>;
  classes: Int;
  meetings?: Maybe<MeetingCreateManyWithoutUserInput>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
  likes?: Maybe<LikeCreateManyWithoutUserInput>;
  participants?: Maybe<ParticipantCreateManyWithoutUserInput>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface PostCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  files?: Maybe<FileCreateManyWithoutPostInput>;
  author?: Maybe<UserCreateOneWithoutPostsInput>;
  classifyNum: Int;
  main: Boolean;
  announcement: Boolean;
  title: String;
  caption: String;
  views?: Maybe<ViewCreateManyWithoutPostInput>;
  likes?: Maybe<LikeCreateManyWithoutPostInput>;
  bulletinList: BulletinListCreateOneWithoutPostsInput;
}

export interface ViewUpsertWithWhereUniqueWithoutPostInput {
  where: ViewWhereUniqueInput;
  update: ViewUpdateWithoutPostDataInput;
  create: ViewCreateWithoutPostInput;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  avatar?: Maybe<String>;
  userName?: Maybe<String>;
  birthday?: Maybe<String>;
  phoneNum?: Maybe<String>;
  email: String;
  introduce?: Maybe<String>;
  password?: Maybe<String>;
  classes: Int;
  meetings?: Maybe<MeetingCreateManyWithoutUserInput>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
  reservations?: Maybe<ReservationCreateManyWithoutUserInput>;
  likes?: Maybe<LikeCreateManyWithoutUserInput>;
  participants?: Maybe<ParticipantCreateManyWithoutUserInput>;
}

export interface ViewScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ViewScalarWhereInput[] | ViewScalarWhereInput>;
  OR?: Maybe<ViewScalarWhereInput[] | ViewScalarWhereInput>;
  NOT?: Maybe<ViewScalarWhereInput[] | ViewScalarWhereInput>;
}

export interface BookCreateWithoutReservationsInput {
  id?: Maybe<ID_Input>;
  photo?: Maybe<FileCreateManyWithoutBookInput>;
  title: String;
  author: String;
  publisher: String;
  content: String;
}

export interface LikeUpdateManyWithoutPostInput {
  create?: Maybe<LikeCreateWithoutPostInput[] | LikeCreateWithoutPostInput>;
  delete?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
  connect?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
  set?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
  disconnect?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
  update?: Maybe<
    | LikeUpdateWithWhereUniqueWithoutPostInput[]
    | LikeUpdateWithWhereUniqueWithoutPostInput
  >;
  upsert?: Maybe<
    | LikeUpsertWithWhereUniqueWithoutPostInput[]
    | LikeUpsertWithWhereUniqueWithoutPostInput
  >;
  deleteMany?: Maybe<LikeScalarWhereInput[] | LikeScalarWhereInput>;
}

export interface PostCreateWithoutLikesInput {
  id?: Maybe<ID_Input>;
  files?: Maybe<FileCreateManyWithoutPostInput>;
  author?: Maybe<UserCreateOneWithoutPostsInput>;
  classifyNum: Int;
  main: Boolean;
  announcement: Boolean;
  title: String;
  caption: String;
  views?: Maybe<ViewCreateManyWithoutPostInput>;
  comments?: Maybe<CommentCreateManyWithoutPostInput>;
  bulletinList: BulletinListCreateOneWithoutPostsInput;
}

export interface LikeUpdateWithWhereUniqueWithoutPostInput {
  where: LikeWhereUniqueInput;
  data: LikeUpdateWithoutPostDataInput;
}

export interface UserCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  avatar?: Maybe<String>;
  userName?: Maybe<String>;
  birthday?: Maybe<String>;
  phoneNum?: Maybe<String>;
  email: String;
  introduce?: Maybe<String>;
  password?: Maybe<String>;
  classes: Int;
  meetings?: Maybe<MeetingCreateManyWithoutUserInput>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  reservations?: Maybe<ReservationCreateManyWithoutUserInput>;
  likes?: Maybe<LikeCreateManyWithoutUserInput>;
  participants?: Maybe<ParticipantCreateManyWithoutUserInput>;
}

export interface LikeUpdateWithoutPostDataInput {
  user?: Maybe<UserUpdateOneWithoutLikesInput>;
}

export interface MeetingCreateWithoutParticipantsInput {
  id?: Maybe<ID_Input>;
  title: String;
  main: Boolean;
  user?: Maybe<UserCreateOneWithoutMeetingsInput>;
  meetingTime: String;
  meetingPlace: String;
  meetingPrice: String;
  deadline: String;
  meetingHeadCounts: Int;
}

export interface UserUpdateOneWithoutLikesInput {
  create?: Maybe<UserCreateWithoutLikesInput>;
  update?: Maybe<UserUpdateWithoutLikesDataInput>;
  upsert?: Maybe<UserUpsertWithoutLikesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface LikeOnCommentCreateWithoutCommentInput {
  id?: Maybe<ID_Input>;
  user?: Maybe<UserCreateOneInput>;
}

export interface UserUpdateWithoutLikesDataInput {
  avatar?: Maybe<String>;
  userName?: Maybe<String>;
  birthday?: Maybe<String>;
  phoneNum?: Maybe<String>;
  email?: Maybe<String>;
  introduce?: Maybe<String>;
  password?: Maybe<String>;
  classes?: Maybe<Int>;
  meetings?: Maybe<MeetingUpdateManyWithoutUserInput>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  reservations?: Maybe<ReservationUpdateManyWithoutUserInput>;
  participants?: Maybe<ParticipantUpdateManyWithoutUserInput>;
}

export interface LikeCreateWithoutPostInput {
  id?: Maybe<ID_Input>;
  user?: Maybe<UserCreateOneWithoutLikesInput>;
}

export interface UserUpsertWithoutLikesInput {
  update: UserUpdateWithoutLikesDataInput;
  create: UserCreateWithoutLikesInput;
}

export interface FileUpdateManyWithoutBookInput {
  create?: Maybe<FileCreateWithoutBookInput[] | FileCreateWithoutBookInput>;
  delete?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  connect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  set?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  disconnect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  update?: Maybe<
    | FileUpdateWithWhereUniqueWithoutBookInput[]
    | FileUpdateWithWhereUniqueWithoutBookInput
  >;
  upsert?: Maybe<
    | FileUpsertWithWhereUniqueWithoutBookInput[]
    | FileUpsertWithWhereUniqueWithoutBookInput
  >;
  deleteMany?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
  updateMany?: Maybe<
    FileUpdateManyWithWhereNestedInput[] | FileUpdateManyWithWhereNestedInput
  >;
}

export interface LikeUpsertWithWhereUniqueWithoutPostInput {
  where: LikeWhereUniqueInput;
  update: LikeUpdateWithoutPostDataInput;
  create: LikeCreateWithoutPostInput;
}

export interface MeetingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MeetingWhereInput>;
  AND?: Maybe<MeetingSubscriptionWhereInput[] | MeetingSubscriptionWhereInput>;
  OR?: Maybe<MeetingSubscriptionWhereInput[] | MeetingSubscriptionWhereInput>;
  NOT?: Maybe<MeetingSubscriptionWhereInput[] | MeetingSubscriptionWhereInput>;
}

export interface PostUpsertWithoutCommentsInput {
  update: PostUpdateWithoutCommentsDataInput;
  create: PostCreateWithoutCommentsInput;
}

export interface PostWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  files_every?: Maybe<FileWhereInput>;
  files_some?: Maybe<FileWhereInput>;
  files_none?: Maybe<FileWhereInput>;
  author?: Maybe<UserWhereInput>;
  classifyNum?: Maybe<Int>;
  classifyNum_not?: Maybe<Int>;
  classifyNum_in?: Maybe<Int[] | Int>;
  classifyNum_not_in?: Maybe<Int[] | Int>;
  classifyNum_lt?: Maybe<Int>;
  classifyNum_lte?: Maybe<Int>;
  classifyNum_gt?: Maybe<Int>;
  classifyNum_gte?: Maybe<Int>;
  main?: Maybe<Boolean>;
  main_not?: Maybe<Boolean>;
  announcement?: Maybe<Boolean>;
  announcement_not?: Maybe<Boolean>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  caption?: Maybe<String>;
  caption_not?: Maybe<String>;
  caption_in?: Maybe<String[] | String>;
  caption_not_in?: Maybe<String[] | String>;
  caption_lt?: Maybe<String>;
  caption_lte?: Maybe<String>;
  caption_gt?: Maybe<String>;
  caption_gte?: Maybe<String>;
  caption_contains?: Maybe<String>;
  caption_not_contains?: Maybe<String>;
  caption_starts_with?: Maybe<String>;
  caption_not_starts_with?: Maybe<String>;
  caption_ends_with?: Maybe<String>;
  caption_not_ends_with?: Maybe<String>;
  views_every?: Maybe<ViewWhereInput>;
  views_some?: Maybe<ViewWhereInput>;
  views_none?: Maybe<ViewWhereInput>;
  likes_every?: Maybe<LikeWhereInput>;
  likes_some?: Maybe<LikeWhereInput>;
  likes_none?: Maybe<LikeWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  bulletinList?: Maybe<BulletinListWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PostWhereInput[] | PostWhereInput>;
  OR?: Maybe<PostWhereInput[] | PostWhereInput>;
  NOT?: Maybe<PostWhereInput[] | PostWhereInput>;
}

export interface CommentUpsertWithWhereUniqueWithoutUserInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutUserDataInput;
  create: CommentCreateWithoutUserInput;
}

export interface PostCreateOneWithoutViewsInput {
  create?: Maybe<PostCreateWithoutViewsInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface UserUpsertWithoutReservationsInput {
  update: UserUpdateWithoutReservationsDataInput;
  create: UserCreateWithoutReservationsInput;
}

export interface ReservationCreateInput {
  id?: Maybe<ID_Input>;
  user?: Maybe<UserCreateOneWithoutReservationsInput>;
  book: BookCreateOneWithoutReservationsInput;
  startDate: String;
  endDate: String;
}

export interface ReservationUpsertWithWhereUniqueWithoutBookInput {
  where: ReservationWhereUniqueInput;
  update: ReservationUpdateWithoutBookDataInput;
  create: ReservationCreateWithoutBookInput;
}

export interface MeetingUpdateManyMutationInput {
  title?: Maybe<String>;
  main?: Maybe<Boolean>;
  meetingTime?: Maybe<String>;
  meetingPlace?: Maybe<String>;
  meetingPrice?: Maybe<String>;
  deadline?: Maybe<String>;
  meetingHeadCounts?: Maybe<Int>;
}

export interface BookUpsertWithWhereUniqueWithoutPhotoInput {
  where: BookWhereUniqueInput;
  update: BookUpdateWithoutPhotoDataInput;
  create: BookCreateWithoutPhotoInput;
}

export interface LikeOnCommentUpdateInput {
  user?: Maybe<UserUpdateOneInput>;
  comment?: Maybe<CommentUpdateOneRequiredWithoutLikesInput>;
}

export interface BookScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  author?: Maybe<String>;
  author_not?: Maybe<String>;
  author_in?: Maybe<String[] | String>;
  author_not_in?: Maybe<String[] | String>;
  author_lt?: Maybe<String>;
  author_lte?: Maybe<String>;
  author_gt?: Maybe<String>;
  author_gte?: Maybe<String>;
  author_contains?: Maybe<String>;
  author_not_contains?: Maybe<String>;
  author_starts_with?: Maybe<String>;
  author_not_starts_with?: Maybe<String>;
  author_ends_with?: Maybe<String>;
  author_not_ends_with?: Maybe<String>;
  publisher?: Maybe<String>;
  publisher_not?: Maybe<String>;
  publisher_in?: Maybe<String[] | String>;
  publisher_not_in?: Maybe<String[] | String>;
  publisher_lt?: Maybe<String>;
  publisher_lte?: Maybe<String>;
  publisher_gt?: Maybe<String>;
  publisher_gte?: Maybe<String>;
  publisher_contains?: Maybe<String>;
  publisher_not_contains?: Maybe<String>;
  publisher_starts_with?: Maybe<String>;
  publisher_not_starts_with?: Maybe<String>;
  publisher_ends_with?: Maybe<String>;
  publisher_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BookScalarWhereInput[] | BookScalarWhereInput>;
  OR?: Maybe<BookScalarWhereInput[] | BookScalarWhereInput>;
  NOT?: Maybe<BookScalarWhereInput[] | BookScalarWhereInput>;
}

export interface FileUpdateManyMutationInput {
  url?: Maybe<String>;
}

export interface BookUpdateManyWithWhereNestedInput {
  where: BookScalarWhereInput;
  data: BookUpdateManyDataInput;
}

export interface CommentCreateInput {
  id?: Maybe<ID_Input>;
  text: String;
  user?: Maybe<UserCreateOneWithoutCommentsInput>;
  post: PostCreateOneWithoutCommentsInput;
  likes?: Maybe<LikeOnCommentCreateManyWithoutCommentInput>;
}

export interface BookUpdateManyDataInput {
  title?: Maybe<String>;
  author?: Maybe<String>;
  publisher?: Maybe<String>;
  content?: Maybe<String>;
}

export interface PostCreateWithoutFilesInput {
  id?: Maybe<ID_Input>;
  author?: Maybe<UserCreateOneWithoutPostsInput>;
  classifyNum: Int;
  main: Boolean;
  announcement: Boolean;
  title: String;
  caption: String;
  views?: Maybe<ViewCreateManyWithoutPostInput>;
  likes?: Maybe<LikeCreateManyWithoutPostInput>;
  comments?: Maybe<CommentCreateManyWithoutPostInput>;
  bulletinList: BulletinListCreateOneWithoutPostsInput;
}

export interface FileUpsertWithWhereUniqueWithoutPostInput {
  where: FileWhereUniqueInput;
  update: FileUpdateWithoutPostDataInput;
  create: FileCreateWithoutPostInput;
}

export interface UserCreateWithoutParticipantsInput {
  id?: Maybe<ID_Input>;
  avatar?: Maybe<String>;
  userName?: Maybe<String>;
  birthday?: Maybe<String>;
  phoneNum?: Maybe<String>;
  email: String;
  introduce?: Maybe<String>;
  password?: Maybe<String>;
  classes: Int;
  meetings?: Maybe<MeetingCreateManyWithoutUserInput>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
  reservations?: Maybe<ReservationCreateManyWithoutUserInput>;
  likes?: Maybe<LikeCreateManyWithoutUserInput>;
}

export interface FileScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
  OR?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
  NOT?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
}

export interface ReservationCreateWithoutBookInput {
  id?: Maybe<ID_Input>;
  user?: Maybe<UserCreateOneWithoutReservationsInput>;
  startDate: String;
  endDate: String;
}

export interface FileUpdateManyWithWhereNestedInput {
  where: FileScalarWhereInput;
  data: FileUpdateManyDataInput;
}

export interface ViewCreateWithoutPostInput {
  id?: Maybe<ID_Input>;
  users?: Maybe<UserCreateOneInput>;
}

export interface FileUpdateManyDataInput {
  url?: Maybe<String>;
}

export interface LikeCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  post: PostCreateOneWithoutLikesInput;
}

export interface PostUpsertWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutAuthorDataInput;
  create: PostCreateWithoutAuthorInput;
}

export interface ParticipantCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  meeting: MeetingCreateOneWithoutParticipantsInput;
}

export interface PostScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  classifyNum?: Maybe<Int>;
  classifyNum_not?: Maybe<Int>;
  classifyNum_in?: Maybe<Int[] | Int>;
  classifyNum_not_in?: Maybe<Int[] | Int>;
  classifyNum_lt?: Maybe<Int>;
  classifyNum_lte?: Maybe<Int>;
  classifyNum_gt?: Maybe<Int>;
  classifyNum_gte?: Maybe<Int>;
  main?: Maybe<Boolean>;
  main_not?: Maybe<Boolean>;
  announcement?: Maybe<Boolean>;
  announcement_not?: Maybe<Boolean>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  caption?: Maybe<String>;
  caption_not?: Maybe<String>;
  caption_in?: Maybe<String[] | String>;
  caption_not_in?: Maybe<String[] | String>;
  caption_lt?: Maybe<String>;
  caption_lte?: Maybe<String>;
  caption_gt?: Maybe<String>;
  caption_gte?: Maybe<String>;
  caption_contains?: Maybe<String>;
  caption_not_contains?: Maybe<String>;
  caption_starts_with?: Maybe<String>;
  caption_not_starts_with?: Maybe<String>;
  caption_ends_with?: Maybe<String>;
  caption_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  OR?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  NOT?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
}

export interface BulletinListCreateWithoutPostsInput {
  id?: Maybe<ID_Input>;
  classifyNum: Int;
}

export interface PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput;
  data: PostUpdateManyDataInput;
}

export interface ReservationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReservationWhereInput>;
  AND?: Maybe<
    ReservationSubscriptionWhereInput[] | ReservationSubscriptionWhereInput
  >;
  OR?: Maybe<
    ReservationSubscriptionWhereInput[] | ReservationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ReservationSubscriptionWhereInput[] | ReservationSubscriptionWhereInput
  >;
}

export interface PostUpdateManyDataInput {
  classifyNum?: Maybe<Int>;
  main?: Maybe<Boolean>;
  announcement?: Maybe<Boolean>;
  title?: Maybe<String>;
  caption?: Maybe<String>;
}

export interface PostUpdateOneRequiredWithoutViewsInput {
  create?: Maybe<PostCreateWithoutViewsInput>;
  update?: Maybe<PostUpdateWithoutViewsDataInput>;
  upsert?: Maybe<PostUpsertWithoutViewsInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface UserUpsertWithoutParticipantsInput {
  update: UserUpdateWithoutParticipantsDataInput;
  create: UserCreateWithoutParticipantsInput;
}

export interface PostCreateInput {
  id?: Maybe<ID_Input>;
  files?: Maybe<FileCreateManyWithoutPostInput>;
  author?: Maybe<UserCreateOneWithoutPostsInput>;
  classifyNum: Int;
  main: Boolean;
  announcement: Boolean;
  title: String;
  caption: String;
  views?: Maybe<ViewCreateManyWithoutPostInput>;
  likes?: Maybe<LikeCreateManyWithoutPostInput>;
  comments?: Maybe<CommentCreateManyWithoutPostInput>;
  bulletinList: BulletinListCreateOneWithoutPostsInput;
}

export interface ParticipantUpsertWithWhereUniqueWithoutMeetingInput {
  where: ParticipantWhereUniqueInput;
  update: ParticipantUpdateWithoutMeetingDataInput;
  create: ParticipantCreateWithoutMeetingInput;
}

export interface LikeOnCommentCreateInput {
  id?: Maybe<ID_Input>;
  user?: Maybe<UserCreateOneInput>;
  comment: CommentCreateOneWithoutLikesInput;
}

export interface MeetingUpsertWithWhereUniqueWithoutUserInput {
  where: MeetingWhereUniqueInput;
  update: MeetingUpdateWithoutUserDataInput;
  create: MeetingCreateWithoutUserInput;
}

export interface BookCreateInput {
  id?: Maybe<ID_Input>;
  photo?: Maybe<FileCreateManyWithoutBookInput>;
  title: String;
  author: String;
  publisher: String;
  content: String;
  reservations?: Maybe<ReservationCreateManyWithoutBookInput>;
}

export interface MeetingScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  main?: Maybe<Boolean>;
  main_not?: Maybe<Boolean>;
  meetingTime?: Maybe<String>;
  meetingTime_not?: Maybe<String>;
  meetingTime_in?: Maybe<String[] | String>;
  meetingTime_not_in?: Maybe<String[] | String>;
  meetingTime_lt?: Maybe<String>;
  meetingTime_lte?: Maybe<String>;
  meetingTime_gt?: Maybe<String>;
  meetingTime_gte?: Maybe<String>;
  meetingTime_contains?: Maybe<String>;
  meetingTime_not_contains?: Maybe<String>;
  meetingTime_starts_with?: Maybe<String>;
  meetingTime_not_starts_with?: Maybe<String>;
  meetingTime_ends_with?: Maybe<String>;
  meetingTime_not_ends_with?: Maybe<String>;
  meetingPlace?: Maybe<String>;
  meetingPlace_not?: Maybe<String>;
  meetingPlace_in?: Maybe<String[] | String>;
  meetingPlace_not_in?: Maybe<String[] | String>;
  meetingPlace_lt?: Maybe<String>;
  meetingPlace_lte?: Maybe<String>;
  meetingPlace_gt?: Maybe<String>;
  meetingPlace_gte?: Maybe<String>;
  meetingPlace_contains?: Maybe<String>;
  meetingPlace_not_contains?: Maybe<String>;
  meetingPlace_starts_with?: Maybe<String>;
  meetingPlace_not_starts_with?: Maybe<String>;
  meetingPlace_ends_with?: Maybe<String>;
  meetingPlace_not_ends_with?: Maybe<String>;
  meetingPrice?: Maybe<String>;
  meetingPrice_not?: Maybe<String>;
  meetingPrice_in?: Maybe<String[] | String>;
  meetingPrice_not_in?: Maybe<String[] | String>;
  meetingPrice_lt?: Maybe<String>;
  meetingPrice_lte?: Maybe<String>;
  meetingPrice_gt?: Maybe<String>;
  meetingPrice_gte?: Maybe<String>;
  meetingPrice_contains?: Maybe<String>;
  meetingPrice_not_contains?: Maybe<String>;
  meetingPrice_starts_with?: Maybe<String>;
  meetingPrice_not_starts_with?: Maybe<String>;
  meetingPrice_ends_with?: Maybe<String>;
  meetingPrice_not_ends_with?: Maybe<String>;
  deadline?: Maybe<String>;
  deadline_not?: Maybe<String>;
  deadline_in?: Maybe<String[] | String>;
  deadline_not_in?: Maybe<String[] | String>;
  deadline_lt?: Maybe<String>;
  deadline_lte?: Maybe<String>;
  deadline_gt?: Maybe<String>;
  deadline_gte?: Maybe<String>;
  deadline_contains?: Maybe<String>;
  deadline_not_contains?: Maybe<String>;
  deadline_starts_with?: Maybe<String>;
  deadline_not_starts_with?: Maybe<String>;
  deadline_ends_with?: Maybe<String>;
  deadline_not_ends_with?: Maybe<String>;
  meetingHeadCounts?: Maybe<Int>;
  meetingHeadCounts_not?: Maybe<Int>;
  meetingHeadCounts_in?: Maybe<Int[] | Int>;
  meetingHeadCounts_not_in?: Maybe<Int[] | Int>;
  meetingHeadCounts_lt?: Maybe<Int>;
  meetingHeadCounts_lte?: Maybe<Int>;
  meetingHeadCounts_gt?: Maybe<Int>;
  meetingHeadCounts_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MeetingScalarWhereInput[] | MeetingScalarWhereInput>;
  OR?: Maybe<MeetingScalarWhereInput[] | MeetingScalarWhereInput>;
  NOT?: Maybe<MeetingScalarWhereInput[] | MeetingScalarWhereInput>;
}

export interface FileCreateWithoutPostInput {
  id?: Maybe<ID_Input>;
  url: String;
  book?: Maybe<BookCreateManyWithoutPhotoInput>;
}

export interface MeetingUpdateManyWithWhereNestedInput {
  where: MeetingScalarWhereInput;
  data: MeetingUpdateManyDataInput;
}

export interface ReservationCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  book: BookCreateOneWithoutReservationsInput;
  startDate: String;
  endDate: String;
}

export interface MeetingUpdateManyDataInput {
  title?: Maybe<String>;
  main?: Maybe<Boolean>;
  meetingTime?: Maybe<String>;
  meetingPlace?: Maybe<String>;
  meetingPrice?: Maybe<String>;
  deadline?: Maybe<String>;
  meetingHeadCounts?: Maybe<Int>;
}

export interface UserCreateWithoutMeetingsInput {
  id?: Maybe<ID_Input>;
  avatar?: Maybe<String>;
  userName?: Maybe<String>;
  birthday?: Maybe<String>;
  phoneNum?: Maybe<String>;
  email: String;
  introduce?: Maybe<String>;
  password?: Maybe<String>;
  classes: Int;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
  reservations?: Maybe<ReservationCreateManyWithoutUserInput>;
  likes?: Maybe<LikeCreateManyWithoutUserInput>;
  participants?: Maybe<ParticipantCreateManyWithoutUserInput>;
}

export interface UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsDataInput;
  create: UserCreateWithoutPostsInput;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FileWhereInput>;
  AND?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
  OR?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
  NOT?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
}

export interface PostUpsertWithWhereUniqueWithoutFilesInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutFilesDataInput;
  create: PostCreateWithoutFilesInput;
}

export interface CommentUpsertWithoutLikesInput {
  update: CommentUpdateWithoutLikesDataInput;
  create: CommentCreateWithoutLikesInput;
}

export interface FileUpsertWithWhereUniqueWithoutBookInput {
  where: FileWhereUniqueInput;
  update: FileUpdateWithoutBookDataInput;
  create: FileCreateWithoutBookInput;
}

export interface MeetingCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  title: String;
  main: Boolean;
  meetingTime: String;
  meetingPlace: String;
  meetingPrice: String;
  deadline: String;
  meetingHeadCounts: Int;
  participants?: Maybe<ParticipantCreateManyWithoutMeetingInput>;
}

export interface BulletinListCreateInput {
  id?: Maybe<ID_Input>;
  classifyNum: Int;
  posts?: Maybe<PostCreateManyWithoutBulletinListInput>;
}

export interface PostCreateWithoutBulletinListInput {
  id?: Maybe<ID_Input>;
  files?: Maybe<FileCreateManyWithoutPostInput>;
  author?: Maybe<UserCreateOneWithoutPostsInput>;
  classifyNum: Int;
  main: Boolean;
  announcement: Boolean;
  title: String;
  caption: String;
  views?: Maybe<ViewCreateManyWithoutPostInput>;
  likes?: Maybe<LikeCreateManyWithoutPostInput>;
  comments?: Maybe<CommentCreateManyWithoutPostInput>;
}

export interface BulletinListUpdateInput {
  classifyNum?: Maybe<Int>;
  posts?: Maybe<PostUpdateManyWithoutBulletinListInput>;
}

export interface BookUpdateManyMutationInput {
  title?: Maybe<String>;
  author?: Maybe<String>;
  publisher?: Maybe<String>;
  content?: Maybe<String>;
}

export interface CommentCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  text: String;
  post: PostCreateOneWithoutCommentsInput;
  likes?: Maybe<LikeOnCommentCreateManyWithoutCommentInput>;
}

export interface FileCreateInput {
  id?: Maybe<ID_Input>;
  url: String;
  post?: Maybe<PostCreateManyWithoutFilesInput>;
  book?: Maybe<BookCreateManyWithoutPhotoInput>;
}

export interface UserUpdateInput {
  avatar?: Maybe<String>;
  userName?: Maybe<String>;
  birthday?: Maybe<String>;
  phoneNum?: Maybe<String>;
  email?: Maybe<String>;
  introduce?: Maybe<String>;
  password?: Maybe<String>;
  classes?: Maybe<Int>;
  meetings?: Maybe<MeetingUpdateManyWithoutUserInput>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  reservations?: Maybe<ReservationUpdateManyWithoutUserInput>;
  likes?: Maybe<LikeUpdateManyWithoutUserInput>;
  participants?: Maybe<ParticipantUpdateManyWithoutUserInput>;
}

export interface UserCreateWithoutLikesInput {
  id?: Maybe<ID_Input>;
  avatar?: Maybe<String>;
  userName?: Maybe<String>;
  birthday?: Maybe<String>;
  phoneNum?: Maybe<String>;
  email: String;
  introduce?: Maybe<String>;
  password?: Maybe<String>;
  classes: Int;
  meetings?: Maybe<MeetingCreateManyWithoutUserInput>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
  reservations?: Maybe<ReservationCreateManyWithoutUserInput>;
  participants?: Maybe<ParticipantCreateManyWithoutUserInput>;
}

export interface CommentCreateWithoutPostInput {
  id?: Maybe<ID_Input>;
  text: String;
  user?: Maybe<UserCreateOneWithoutCommentsInput>;
  likes?: Maybe<LikeOnCommentCreateManyWithoutCommentInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface ViewPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
}

export interface ViewPreviousValuesPromise
  extends Promise<ViewPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ViewPreviousValuesSubscription
  extends Promise<AsyncIterator<ViewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateBook {
  count: Int;
}

export interface AggregateBookPromise
  extends Promise<AggregateBook>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookSubscription
  extends Promise<AsyncIterator<AggregateBook>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  avatar?: String;
  userName?: String;
  birthday?: String;
  phoneNum?: String;
  email: String;
  introduce?: String;
  password?: String;
  classes: Int;
  createdAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  avatar: () => Promise<String>;
  userName: () => Promise<String>;
  birthday: () => Promise<String>;
  phoneNum: () => Promise<String>;
  email: () => Promise<String>;
  introduce: () => Promise<String>;
  password: () => Promise<String>;
  classes: () => Promise<Int>;
  meetings: <T = FragmentableArray<Meeting>>(args?: {
    where?: MeetingWhereInput;
    orderBy?: MeetingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  posts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reservations: <T = FragmentableArray<Reservation>>(args?: {
    where?: ReservationWhereInput;
    orderBy?: ReservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likes: <T = FragmentableArray<Like>>(args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  participants: <T = FragmentableArray<Participant>>(args?: {
    where?: ParticipantWhereInput;
    orderBy?: ParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  avatar: () => Promise<AsyncIterator<String>>;
  userName: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<String>>;
  phoneNum: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  introduce: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  classes: () => Promise<AsyncIterator<Int>>;
  meetings: <T = Promise<AsyncIterator<MeetingSubscription>>>(args?: {
    where?: MeetingWhereInput;
    orderBy?: MeetingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  posts: <T = Promise<AsyncIterator<PostSubscription>>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reservations: <T = Promise<AsyncIterator<ReservationSubscription>>>(args?: {
    where?: ReservationWhereInput;
    orderBy?: ReservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likes: <T = Promise<AsyncIterator<LikeSubscription>>>(args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  participants: <T = Promise<AsyncIterator<ParticipantSubscription>>>(args?: {
    where?: ParticipantWhereInput;
    orderBy?: ParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  avatar: () => Promise<String>;
  userName: () => Promise<String>;
  birthday: () => Promise<String>;
  phoneNum: () => Promise<String>;
  email: () => Promise<String>;
  introduce: () => Promise<String>;
  password: () => Promise<String>;
  classes: () => Promise<Int>;
  meetings: <T = FragmentableArray<Meeting>>(args?: {
    where?: MeetingWhereInput;
    orderBy?: MeetingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  posts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reservations: <T = FragmentableArray<Reservation>>(args?: {
    where?: ReservationWhereInput;
    orderBy?: ReservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likes: <T = FragmentableArray<Like>>(args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  participants: <T = FragmentableArray<Participant>>(args?: {
    where?: ParticipantWhereInput;
    orderBy?: ParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BookEdge {
  node: Book;
  cursor: String;
}

export interface BookEdgePromise extends Promise<BookEdge>, Fragmentable {
  node: <T = BookPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookEdgeSubscription
  extends Promise<AsyncIterator<BookEdge>>,
    Fragmentable {
  node: <T = BookSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Post {
  id: ID_Output;
  classifyNum: Int;
  main: Boolean;
  announcement: Boolean;
  title: String;
  caption: String;
  createdAt: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  id: () => Promise<ID_Output>;
  files: <T = FragmentableArray<File>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserPromise>() => T;
  classifyNum: () => Promise<Int>;
  main: () => Promise<Boolean>;
  announcement: () => Promise<Boolean>;
  title: () => Promise<String>;
  caption: () => Promise<String>;
  views: <T = FragmentableArray<View>>(args?: {
    where?: ViewWhereInput;
    orderBy?: ViewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likes: <T = FragmentableArray<Like>>(args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bulletinList: <T = BulletinListPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostSubscription
  extends Promise<AsyncIterator<Post>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  files: <T = Promise<AsyncIterator<FileSubscription>>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserSubscription>() => T;
  classifyNum: () => Promise<AsyncIterator<Int>>;
  main: () => Promise<AsyncIterator<Boolean>>;
  announcement: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  caption: () => Promise<AsyncIterator<String>>;
  views: <T = Promise<AsyncIterator<ViewSubscription>>>(args?: {
    where?: ViewWhereInput;
    orderBy?: ViewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likes: <T = Promise<AsyncIterator<LikeSubscription>>>(args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bulletinList: <T = BulletinListSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PostNullablePromise
  extends Promise<Post | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  files: <T = FragmentableArray<File>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserPromise>() => T;
  classifyNum: () => Promise<Int>;
  main: () => Promise<Boolean>;
  announcement: () => Promise<Boolean>;
  title: () => Promise<String>;
  caption: () => Promise<String>;
  views: <T = FragmentableArray<View>>(args?: {
    where?: ViewWhereInput;
    orderBy?: ViewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likes: <T = FragmentableArray<Like>>(args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bulletinList: <T = BulletinListPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface File {
  id: ID_Output;
  url: String;
  createdAt: DateTimeOutput;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  post: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  book: <T = FragmentableArray<Book>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  post: <T = Promise<AsyncIterator<PostSubscription>>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  book: <T = Promise<AsyncIterator<BookSubscription>>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FileNullablePromise
  extends Promise<File | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  post: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  book: <T = FragmentableArray<Book>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateView {
  count: Int;
}

export interface AggregateViewPromise
  extends Promise<AggregateView>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateViewSubscription
  extends Promise<AsyncIterator<AggregateView>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ViewConnection {
  pageInfo: PageInfo;
  edges: ViewEdge[];
}

export interface ViewConnectionPromise
  extends Promise<ViewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ViewEdge>>() => T;
  aggregate: <T = AggregateViewPromise>() => T;
}

export interface ViewConnectionSubscription
  extends Promise<AsyncIterator<ViewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ViewEdgeSubscription>>>() => T;
  aggregate: <T = AggregateViewSubscription>() => T;
}

export interface BookConnection {
  pageInfo: PageInfo;
  edges: BookEdge[];
}

export interface BookConnectionPromise
  extends Promise<BookConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookEdge>>() => T;
  aggregate: <T = AggregateBookPromise>() => T;
}

export interface BookConnectionSubscription
  extends Promise<AsyncIterator<BookConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Book {
  id: ID_Output;
  title: String;
  author: String;
  publisher: String;
  content: String;
  createdAt: DateTimeOutput;
}

export interface BookPromise extends Promise<Book>, Fragmentable {
  id: () => Promise<ID_Output>;
  photo: <T = FragmentableArray<File>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  title: () => Promise<String>;
  author: () => Promise<String>;
  publisher: () => Promise<String>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  reservations: <T = FragmentableArray<Reservation>>(args?: {
    where?: ReservationWhereInput;
    orderBy?: ReservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BookSubscription
  extends Promise<AsyncIterator<Book>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  photo: <T = Promise<AsyncIterator<FileSubscription>>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  title: () => Promise<AsyncIterator<String>>;
  author: () => Promise<AsyncIterator<String>>;
  publisher: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  reservations: <T = Promise<AsyncIterator<ReservationSubscription>>>(args?: {
    where?: ReservationWhereInput;
    orderBy?: ReservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BookNullablePromise
  extends Promise<Book | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  photo: <T = FragmentableArray<File>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  title: () => Promise<String>;
  author: () => Promise<String>;
  publisher: () => Promise<String>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  reservations: <T = FragmentableArray<Reservation>>(args?: {
    where?: ReservationWhereInput;
    orderBy?: ReservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateReservation {
  count: Int;
}

export interface AggregateReservationPromise
  extends Promise<AggregateReservation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReservationSubscription
  extends Promise<AsyncIterator<AggregateReservation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookSubscriptionPayload {
  mutation: MutationType;
  node: Book;
  updatedFields: String[];
  previousValues: BookPreviousValues;
}

export interface BookSubscriptionPayloadPromise
  extends Promise<BookSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookPreviousValuesPromise>() => T;
}

export interface BookSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookPreviousValuesSubscription>() => T;
}

export interface ReservationConnection {
  pageInfo: PageInfo;
  edges: ReservationEdge[];
}

export interface ReservationConnectionPromise
  extends Promise<ReservationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReservationEdge>>() => T;
  aggregate: <T = AggregateReservationPromise>() => T;
}

export interface ReservationConnectionSubscription
  extends Promise<AsyncIterator<ReservationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReservationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReservationSubscription>() => T;
}

export interface BookPreviousValues {
  id: ID_Output;
  title: String;
  author: String;
  publisher: String;
  content: String;
  createdAt: DateTimeOutput;
}

export interface BookPreviousValuesPromise
  extends Promise<BookPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  author: () => Promise<String>;
  publisher: () => Promise<String>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BookPreviousValuesSubscription
  extends Promise<AsyncIterator<BookPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  author: () => Promise<AsyncIterator<String>>;
  publisher: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PostEdge {
  node: Post;
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription
  extends Promise<AsyncIterator<PostEdge>>,
    Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BulletinList {
  id: ID_Output;
  classifyNum: Int;
}

export interface BulletinListPromise
  extends Promise<BulletinList>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  classifyNum: () => Promise<Int>;
  posts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BulletinListSubscription
  extends Promise<AsyncIterator<BulletinList>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  classifyNum: () => Promise<AsyncIterator<Int>>;
  posts: <T = Promise<AsyncIterator<PostSubscription>>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BulletinListNullablePromise
  extends Promise<BulletinList | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  classifyNum: () => Promise<Int>;
  posts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateParticipant {
  count: Int;
}

export interface AggregateParticipantPromise
  extends Promise<AggregateParticipant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateParticipantSubscription
  extends Promise<AsyncIterator<AggregateParticipant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BulletinListSubscriptionPayload {
  mutation: MutationType;
  node: BulletinList;
  updatedFields: String[];
  previousValues: BulletinListPreviousValues;
}

export interface BulletinListSubscriptionPayloadPromise
  extends Promise<BulletinListSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BulletinListPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BulletinListPreviousValuesPromise>() => T;
}

export interface BulletinListSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BulletinListSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BulletinListSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BulletinListPreviousValuesSubscription>() => T;
}

export interface ParticipantConnection {
  pageInfo: PageInfo;
  edges: ParticipantEdge[];
}

export interface ParticipantConnectionPromise
  extends Promise<ParticipantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ParticipantEdge>>() => T;
  aggregate: <T = AggregateParticipantPromise>() => T;
}

export interface ParticipantConnectionSubscription
  extends Promise<AsyncIterator<ParticipantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ParticipantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateParticipantSubscription>() => T;
}

export interface BulletinListPreviousValues {
  id: ID_Output;
  classifyNum: Int;
}

export interface BulletinListPreviousValuesPromise
  extends Promise<BulletinListPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  classifyNum: () => Promise<Int>;
}

export interface BulletinListPreviousValuesSubscription
  extends Promise<AsyncIterator<BulletinListPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  classifyNum: () => Promise<AsyncIterator<Int>>;
}

export interface MeetingEdge {
  node: Meeting;
  cursor: String;
}

export interface MeetingEdgePromise extends Promise<MeetingEdge>, Fragmentable {
  node: <T = MeetingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MeetingEdgeSubscription
  extends Promise<AsyncIterator<MeetingEdge>>,
    Fragmentable {
  node: <T = MeetingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface View {
  id: ID_Output;
  createdAt: DateTimeOutput;
}

export interface ViewPromise extends Promise<View>, Fragmentable {
  id: () => Promise<ID_Output>;
  users: <T = UserPromise>() => T;
  post: <T = PostPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ViewSubscription
  extends Promise<AsyncIterator<View>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  users: <T = UserSubscription>() => T;
  post: <T = PostSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ViewNullablePromise
  extends Promise<View | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  users: <T = UserPromise>() => T;
  post: <T = PostPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AggregateLikeOnComment {
  count: Int;
}

export interface AggregateLikeOnCommentPromise
  extends Promise<AggregateLikeOnComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLikeOnCommentSubscription
  extends Promise<AsyncIterator<AggregateLikeOnComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface LikeOnCommentConnection {
  pageInfo: PageInfo;
  edges: LikeOnCommentEdge[];
}

export interface LikeOnCommentConnectionPromise
  extends Promise<LikeOnCommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LikeOnCommentEdge>>() => T;
  aggregate: <T = AggregateLikeOnCommentPromise>() => T;
}

export interface LikeOnCommentConnectionSubscription
  extends Promise<AsyncIterator<LikeOnCommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LikeOnCommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLikeOnCommentSubscription>() => T;
}

export interface CommentPreviousValues {
  id: ID_Output;
  text: String;
  createdAt: DateTimeOutput;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LikeEdge {
  node: Like;
  cursor: String;
}

export interface LikeEdgePromise extends Promise<LikeEdge>, Fragmentable {
  node: <T = LikePromise>() => T;
  cursor: () => Promise<String>;
}

export interface LikeEdgeSubscription
  extends Promise<AsyncIterator<LikeEdge>>,
    Fragmentable {
  node: <T = LikeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Like {
  id: ID_Output;
  createdAt: DateTimeOutput;
}

export interface LikePromise extends Promise<Like>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  post: <T = PostPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface LikeSubscription
  extends Promise<AsyncIterator<Like>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  post: <T = PostSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LikeNullablePromise
  extends Promise<Like | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  post: <T = PostPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface FilePreviousValues {
  id: ID_Output;
  url: String;
  createdAt: DateTimeOutput;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Meeting {
  id: ID_Output;
  title: String;
  main: Boolean;
  meetingTime: String;
  meetingPlace: String;
  meetingPrice: String;
  deadline: String;
  meetingHeadCounts: Int;
  createdAt: DateTimeOutput;
}

export interface MeetingPromise extends Promise<Meeting>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  main: () => Promise<Boolean>;
  user: <T = UserPromise>() => T;
  meetingTime: () => Promise<String>;
  meetingPlace: () => Promise<String>;
  meetingPrice: () => Promise<String>;
  deadline: () => Promise<String>;
  meetingHeadCounts: () => Promise<Int>;
  participants: <T = FragmentableArray<Participant>>(args?: {
    where?: ParticipantWhereInput;
    orderBy?: ParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface MeetingSubscription
  extends Promise<AsyncIterator<Meeting>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  main: () => Promise<AsyncIterator<Boolean>>;
  user: <T = UserSubscription>() => T;
  meetingTime: () => Promise<AsyncIterator<String>>;
  meetingPlace: () => Promise<AsyncIterator<String>>;
  meetingPrice: () => Promise<AsyncIterator<String>>;
  deadline: () => Promise<AsyncIterator<String>>;
  meetingHeadCounts: () => Promise<AsyncIterator<Int>>;
  participants: <T = Promise<AsyncIterator<ParticipantSubscription>>>(args?: {
    where?: ParticipantWhereInput;
    orderBy?: ParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MeetingNullablePromise
  extends Promise<Meeting | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  main: () => Promise<Boolean>;
  user: <T = UserPromise>() => T;
  meetingTime: () => Promise<String>;
  meetingPlace: () => Promise<String>;
  meetingPrice: () => Promise<String>;
  deadline: () => Promise<String>;
  meetingHeadCounts: () => Promise<Int>;
  participants: <T = FragmentableArray<Participant>>(args?: {
    where?: ParticipantWhereInput;
    orderBy?: ParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AggregateBulletinList {
  count: Int;
}

export interface AggregateBulletinListPromise
  extends Promise<AggregateBulletinList>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBulletinListSubscription
  extends Promise<AsyncIterator<AggregateBulletinList>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LikeSubscriptionPayload {
  mutation: MutationType;
  node: Like;
  updatedFields: String[];
  previousValues: LikePreviousValues;
}

export interface LikeSubscriptionPayloadPromise
  extends Promise<LikeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LikePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LikePreviousValuesPromise>() => T;
}

export interface LikeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LikeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LikeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LikePreviousValuesSubscription>() => T;
}

export interface BulletinListConnection {
  pageInfo: PageInfo;
  edges: BulletinListEdge[];
}

export interface BulletinListConnectionPromise
  extends Promise<BulletinListConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BulletinListEdge>>() => T;
  aggregate: <T = AggregateBulletinListPromise>() => T;
}

export interface BulletinListConnectionSubscription
  extends Promise<AsyncIterator<BulletinListConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BulletinListEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBulletinListSubscription>() => T;
}

export interface LikePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
}

export interface LikePreviousValuesPromise
  extends Promise<LikePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface LikePreviousValuesSubscription
  extends Promise<AsyncIterator<LikePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ViewEdge {
  node: View;
  cursor: String;
}

export interface ViewEdgePromise extends Promise<ViewEdge>, Fragmentable {
  node: <T = ViewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ViewEdgeSubscription
  extends Promise<AsyncIterator<ViewEdge>>,
    Fragmentable {
  node: <T = ViewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Reservation {
  id: ID_Output;
  startDate: String;
  endDate: String;
  createdAt: DateTimeOutput;
}

export interface ReservationPromise extends Promise<Reservation>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  book: <T = BookPromise>() => T;
  startDate: () => Promise<String>;
  endDate: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ReservationSubscription
  extends Promise<AsyncIterator<Reservation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  book: <T = BookSubscription>() => T;
  startDate: () => Promise<AsyncIterator<String>>;
  endDate: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReservationNullablePromise
  extends Promise<Reservation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  book: <T = BookPromise>() => T;
  startDate: () => Promise<String>;
  endDate: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface LikeOnCommentSubscriptionPayload {
  mutation: MutationType;
  node: LikeOnComment;
  updatedFields: String[];
  previousValues: LikeOnCommentPreviousValues;
}

export interface LikeOnCommentSubscriptionPayloadPromise
  extends Promise<LikeOnCommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LikeOnCommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LikeOnCommentPreviousValuesPromise>() => T;
}

export interface LikeOnCommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LikeOnCommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LikeOnCommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LikeOnCommentPreviousValuesSubscription>() => T;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise
  extends Promise<AggregatePost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LikeOnCommentPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
}

export interface LikeOnCommentPreviousValuesPromise
  extends Promise<LikeOnCommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface LikeOnCommentPreviousValuesSubscription
  extends Promise<AsyncIterator<LikeOnCommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ParticipantEdge {
  node: Participant;
  cursor: String;
}

export interface ParticipantEdgePromise
  extends Promise<ParticipantEdge>,
    Fragmentable {
  node: <T = ParticipantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ParticipantEdgeSubscription
  extends Promise<AsyncIterator<ParticipantEdge>>,
    Fragmentable {
  node: <T = ParticipantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LikeOnComment {
  id: ID_Output;
  createdAt: DateTimeOutput;
}

export interface LikeOnCommentPromise
  extends Promise<LikeOnComment>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  comment: <T = CommentPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface LikeOnCommentSubscription
  extends Promise<AsyncIterator<LikeOnComment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  comment: <T = CommentSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LikeOnCommentNullablePromise
  extends Promise<LikeOnComment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  comment: <T = CommentPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface MeetingConnection {
  pageInfo: PageInfo;
  edges: MeetingEdge[];
}

export interface MeetingConnectionPromise
  extends Promise<MeetingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MeetingEdge>>() => T;
  aggregate: <T = AggregateMeetingPromise>() => T;
}

export interface MeetingConnectionSubscription
  extends Promise<AsyncIterator<MeetingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MeetingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMeetingSubscription>() => T;
}

export interface MeetingSubscriptionPayload {
  mutation: MutationType;
  node: Meeting;
  updatedFields: String[];
  previousValues: MeetingPreviousValues;
}

export interface MeetingSubscriptionPayloadPromise
  extends Promise<MeetingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MeetingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MeetingPreviousValuesPromise>() => T;
}

export interface MeetingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MeetingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MeetingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MeetingPreviousValuesSubscription>() => T;
}

export interface AggregateLike {
  count: Int;
}

export interface AggregateLikePromise
  extends Promise<AggregateLike>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLikeSubscription
  extends Promise<AsyncIterator<AggregateLike>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MeetingPreviousValues {
  id: ID_Output;
  title: String;
  main: Boolean;
  meetingTime: String;
  meetingPlace: String;
  meetingPrice: String;
  deadline: String;
  meetingHeadCounts: Int;
  createdAt: DateTimeOutput;
}

export interface MeetingPreviousValuesPromise
  extends Promise<MeetingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  main: () => Promise<Boolean>;
  meetingTime: () => Promise<String>;
  meetingPlace: () => Promise<String>;
  meetingPrice: () => Promise<String>;
  deadline: () => Promise<String>;
  meetingHeadCounts: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface MeetingPreviousValuesSubscription
  extends Promise<AsyncIterator<MeetingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  main: () => Promise<AsyncIterator<Boolean>>;
  meetingTime: () => Promise<AsyncIterator<String>>;
  meetingPlace: () => Promise<AsyncIterator<String>>;
  meetingPrice: () => Promise<AsyncIterator<String>>;
  deadline: () => Promise<AsyncIterator<String>>;
  meetingHeadCounts: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  avatar?: String;
  userName?: String;
  birthday?: String;
  phoneNum?: String;
  email: String;
  introduce?: String;
  password?: String;
  classes: Int;
  createdAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  avatar: () => Promise<String>;
  userName: () => Promise<String>;
  birthday: () => Promise<String>;
  phoneNum: () => Promise<String>;
  email: () => Promise<String>;
  introduce: () => Promise<String>;
  password: () => Promise<String>;
  classes: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  avatar: () => Promise<AsyncIterator<String>>;
  userName: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<String>>;
  phoneNum: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  introduce: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  classes: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface ParticipantSubscriptionPayload {
  mutation: MutationType;
  node: Participant;
  updatedFields: String[];
  previousValues: ParticipantPreviousValues;
}

export interface ParticipantSubscriptionPayloadPromise
  extends Promise<ParticipantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ParticipantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ParticipantPreviousValuesPromise>() => T;
}

export interface ParticipantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ParticipantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ParticipantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ParticipantPreviousValuesSubscription>() => T;
}

export interface ViewSubscriptionPayload {
  mutation: MutationType;
  node: View;
  updatedFields: String[];
  previousValues: ViewPreviousValues;
}

export interface ViewSubscriptionPayloadPromise
  extends Promise<ViewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ViewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ViewPreviousValuesPromise>() => T;
}

export interface ViewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ViewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ViewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ViewPreviousValuesSubscription>() => T;
}

export interface ParticipantPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
}

export interface ParticipantPreviousValuesPromise
  extends Promise<ParticipantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ParticipantPreviousValuesSubscription
  extends Promise<AsyncIterator<ParticipantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReservationEdge {
  node: Reservation;
  cursor: String;
}

export interface ReservationEdgePromise
  extends Promise<ReservationEdge>,
    Fragmentable {
  node: <T = ReservationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReservationEdgeSubscription
  extends Promise<AsyncIterator<ReservationEdge>>,
    Fragmentable {
  node: <T = ReservationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Comment {
  id: ID_Output;
  text: String;
  createdAt: DateTimeOutput;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  user: <T = UserPromise>() => T;
  post: <T = PostPromise>() => T;
  likes: <T = FragmentableArray<LikeOnComment>>(args?: {
    where?: LikeOnCommentWhereInput;
    orderBy?: LikeOnCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  post: <T = PostSubscription>() => T;
  likes: <T = Promise<AsyncIterator<LikeOnCommentSubscription>>>(args?: {
    where?: LikeOnCommentWhereInput;
    orderBy?: LikeOnCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentNullablePromise
  extends Promise<Comment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  user: <T = UserPromise>() => T;
  post: <T = PostPromise>() => T;
  likes: <T = FragmentableArray<LikeOnComment>>(args?: {
    where?: LikeOnCommentWhereInput;
    orderBy?: LikeOnCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AggregateMeeting {
  count: Int;
}

export interface AggregateMeetingPromise
  extends Promise<AggregateMeeting>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMeetingSubscription
  extends Promise<AsyncIterator<AggregateMeeting>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  node: Post;
  updatedFields: String[];
  previousValues: PostPreviousValues;
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface LikeConnection {
  pageInfo: PageInfo;
  edges: LikeEdge[];
}

export interface LikeConnectionPromise
  extends Promise<LikeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LikeEdge>>() => T;
  aggregate: <T = AggregateLikePromise>() => T;
}

export interface LikeConnectionSubscription
  extends Promise<AsyncIterator<LikeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LikeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLikeSubscription>() => T;
}

export interface BulletinListEdge {
  node: BulletinList;
  cursor: String;
}

export interface BulletinListEdgePromise
  extends Promise<BulletinListEdge>,
    Fragmentable {
  node: <T = BulletinListPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BulletinListEdgeSubscription
  extends Promise<AsyncIterator<BulletinListEdge>>,
    Fragmentable {
  node: <T = BulletinListSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ReservationPreviousValues {
  id: ID_Output;
  startDate: String;
  endDate: String;
  createdAt: DateTimeOutput;
}

export interface ReservationPreviousValuesPromise
  extends Promise<ReservationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  startDate: () => Promise<String>;
  endDate: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ReservationPreviousValuesSubscription
  extends Promise<AsyncIterator<ReservationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startDate: () => Promise<AsyncIterator<String>>;
  endDate: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReservationSubscriptionPayload {
  mutation: MutationType;
  node: Reservation;
  updatedFields: String[];
  previousValues: ReservationPreviousValues;
}

export interface ReservationSubscriptionPayloadPromise
  extends Promise<ReservationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReservationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReservationPreviousValuesPromise>() => T;
}

export interface ReservationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReservationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReservationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReservationPreviousValuesSubscription>() => T;
}

export interface Participant {
  id: ID_Output;
  createdAt: DateTimeOutput;
}

export interface ParticipantPromise extends Promise<Participant>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  meeting: <T = MeetingPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ParticipantSubscription
  extends Promise<AsyncIterator<Participant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  meeting: <T = MeetingSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ParticipantNullablePromise
  extends Promise<Participant | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  meeting: <T = MeetingPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface PostPreviousValues {
  id: ID_Output;
  classifyNum: Int;
  main: Boolean;
  announcement: Boolean;
  title: String;
  caption: String;
  createdAt: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface PostPreviousValuesPromise
  extends Promise<PostPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  classifyNum: () => Promise<Int>;
  main: () => Promise<Boolean>;
  announcement: () => Promise<Boolean>;
  title: () => Promise<String>;
  caption: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  classifyNum: () => Promise<AsyncIterator<Int>>;
  main: () => Promise<AsyncIterator<Boolean>>;
  announcement: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  caption: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LikeOnCommentEdge {
  node: LikeOnComment;
  cursor: String;
}

export interface LikeOnCommentEdgePromise
  extends Promise<LikeOnCommentEdge>,
    Fragmentable {
  node: <T = LikeOnCommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LikeOnCommentEdgeSubscription
  extends Promise<AsyncIterator<LikeOnCommentEdge>>,
    Fragmentable {
  node: <T = LikeOnCommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PostConnection {
  pageInfo: PageInfo;
  edges: PostEdge[];
}

export interface PostConnectionPromise
  extends Promise<PostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Post",
    embedded: false
  },
  {
    name: "BulletinList",
    embedded: false
  },
  {
    name: "Like",
    embedded: false
  },
  {
    name: "LikeOnComment",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "Meeting",
    embedded: false
  },
  {
    name: "Participant",
    embedded: false
  },
  {
    name: "Book",
    embedded: false
  },
  {
    name: "Reservation",
    embedded: false
  },
  {
    name: "View",
    embedded: false
  },
  {
    name: "File",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
